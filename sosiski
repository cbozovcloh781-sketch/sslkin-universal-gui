if not game:IsLoaded() then game.Loaded:Wait() end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")

local Config = {
    ESP = {
        Enabled     = true,
        TeamCheck   = false,
        ShowOutline = true,
        ShowLines   = false,
        Rainbow     = false,
        FillColor   = Color3.fromRGB(255,255,255),
        OutlineColor= Color3.fromRGB(255,255,255),
        TextColor   = Color3.fromRGB(255,255,255),
        LineColor   = Color3.fromRGB(255,255,255),
        FillTransparency    = 0.5,
        OutlineTransparency = 0,
        Font        = Enum.Font.SciFi,
        TeamColor   = Color3.fromRGB(0,255,0),
        EnemyColor  = Color3.fromRGB(255,0,0),
        ToggleKey   = nil,
    },
    Aimbot = {
        Enabled         = false,
        TeamCheck       = false,
        VisibilityCheck = true,
        FOV             = 150,
        ToggleKey       = nil,
        FOVColor        = Color3.fromRGB(255,128,128),
        FOVRainbow      = false,
    },
    MenuCollapsed = false,
}

local FlyConfig = {
    Enabled = false,
    Speed = 1,
    ToggleKey = nil,
}

local NoClipConfig = {
    Enabled = false,
    ToggleKey = nil,
    ForceToggleKey = nil,
}

local SpeedHackConfig = {
    Enabled = false,
    Speed = 1,
    ToggleKey = nil,
    UseJumpPower = false,
}

local LongJumpConfig = {
    Enabled = false,
    JumpPower = 150,
    ToggleKey = nil,
}

local InfiniteJumpConfig = {
    Enabled = false,
    JumpPower = 50,
    ToggleKey = nil,
}

local TeleportConfig = {
    Enabled = false,
    TargetPlayer = nil,
    OriginalPosition = nil,
    ToggleKey = nil,
    SelectedPlayerName = nil,
    UseStealthMode = true,
    TeleportSpeed = 1200,
    ReturnSpeed = 2000,
    BehindPlayerDistance = 3.0,
    StabilizationTime = 0.5,
    MaxSpeedResetTime = 2.0,
    SpeedResetThreshold = 50,
    InstantTurnSpeed = 600,
    SmoothingFactor = 0.15,
    MaxCorrectionSpeed = 300,
    StabilizationThreshold = 0.8,
}

local YBAConfig = {
    Enabled = false,
    ToggleKey = nil,
    StandRange = 100000,
    FreezePlayer = true,
    SwitchCamera = true,
    ItemESP = {
        Enabled = false,
        Items = {}
    },
    UndergroundControl = {
        FlightSpeed = 100
    }
}

local AntiTimeStopConfig = {
    Enabled = false,
    ToggleKey = nil,
}

-- Новый интерфейс меню
local FrostwareGui = Instance.new("ScreenGui", CoreGui)
FrostwareGui.Name = "FrostwareGui"
FrostwareGui.ResetOnSpawn = false

-- Переменные для функций
local isFlying = false
local flyConnections = {}
local isNoClipping = false
local noClipConnections = {}
local isSpeedHacking = false
local speedHackConnections = {}
local isLongJumping = false
local longJumpConnections = {}
local isInfiniteJumping = false
local infiniteJumpConnections = {}
local isTeleporting = false
local teleportConnections = {}
local isYBAEnabled = false
local ybaConnections = {}
local isUndergroundControlEnabled = false
local undergroundControlConnections = {}
local itemESPConnections = {}
local itemESPElements = {}

-- Функции
local function startFly()
    local plr = Players.LocalPlayer
    local char = plr.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local root = char and char:FindFirstChild("HumanoidRootPart")
    
    if not hum or not root then return end
    
    isFlying = true
    
    local flyOriginalJumpPower = hum.JumpPower
    local flyOriginalJumpHeight = hum.JumpHeight
    local flyOriginalGravity = workspace.Gravity
    local flyOriginalHipHeight = hum.HipHeight
    
    hum.JumpPower = 0
    hum.JumpHeight = 0
    workspace.Gravity = 0
    hum.HipHeight = 0
    
    local ctrl = {f = 0, b = 0, l = 0, r = 0, u = 0, d = 0}
    
    local inputDown = UserInputService.InputBegan:Connect(function(input, gp)
        if gp then return end
        if input.KeyCode == Enum.KeyCode.W then ctrl.f = 1
        elseif input.KeyCode == Enum.KeyCode.S then ctrl.b = -1
        elseif input.KeyCode == Enum.KeyCode.A then ctrl.l = -1
        elseif input.KeyCode == Enum.KeyCode.D then ctrl.r = 1
        elseif input.KeyCode == Enum.KeyCode.Space then ctrl.u = 1
        elseif input.KeyCode == Enum.KeyCode.LeftControl then ctrl.d = -1 end
    end)
    
    local inputUp = UserInputService.InputEnded:Connect(function(input, gp)
        if gp then return end
        if input.KeyCode == Enum.KeyCode.W then ctrl.f = 0
        elseif input.KeyCode == Enum.KeyCode.S then ctrl.b = 0
        elseif input.KeyCode == Enum.KeyCode.A then ctrl.l = 0
        elseif input.KeyCode == Enum.KeyCode.D then ctrl.r = 0
        elseif input.KeyCode == Enum.KeyCode.Space then ctrl.u = 0
        elseif input.KeyCode == Enum.KeyCode.LeftControl then ctrl.d = 0 end
    end)
    
    local renderConnection = RunService.RenderStepped:Connect(function()
        if not isFlying or not char or not char:FindFirstChild("Humanoid") or not root then
            if hum then
                hum.JumpPower = flyOriginalJumpPower
                hum.JumpHeight = flyOriginalJumpHeight
                hum.HipHeight = flyOriginalHipHeight
            end
            if not isNoClipping then
                workspace.Gravity = flyOriginalGravity
            end
            
            inputDown:Disconnect()
            inputUp:Disconnect()
            renderConnection:Disconnect()
            return
        end
        
        local cam = workspace.CurrentCamera
        if not cam then return end
        
        local forward = cam.CFrame.lookVector
        local right = cam.CFrame.rightVector
        local up = Vector3.new(0, 1, 0)
        
        local moveVector = Vector3.new(0, 0, 0)
        moveVector = moveVector + (forward * (ctrl.f + ctrl.b))
        moveVector = moveVector + (right * (ctrl.r + ctrl.l))
        moveVector = moveVector + (up * (ctrl.u + ctrl.d))
        
        if moveVector.Magnitude > 0 then
            moveVector = moveVector.Unit * (FlyConfig.Speed * 10)
            local bv = root:FindFirstChild("BodyVelocity")
            if not bv then
                bv = Instance.new("BodyVelocity", root)
                bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
            end
            bv.Velocity = moveVector
        else
            local bv = root:FindFirstChild("BodyVelocity")
            if bv then
                bv.Velocity = Vector3.new(0, 0, 0)
            end
        end
    end)
    
    table.insert(flyConnections, inputDown)
    table.insert(flyConnections, inputUp)
    table.insert(flyConnections, renderConnection)
end

local function stopFly()
    isFlying = false
    
    local char = Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local root = char and char:FindFirstChild("HumanoidRootPart")
    
    if hum then
        hum.JumpPower = 50
        hum.JumpHeight = 7.2
        hum.HipHeight = 2
    end
    
    workspace.Gravity = 196.2
    
    if root then
        local bv = root:FindFirstChild("BodyVelocity")
        if bv then
            bv:Destroy()
        end
    end
    
    for _, connection in ipairs(flyConnections) do
        if connection then
            pcall(function() connection:Disconnect() end)
        end
    end
    flyConnections = {}
end

local function startNoClip()
    local char = Players.LocalPlayer.Character
    if not char then return end
    
    isNoClipping = true
    
    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") and part.CanCollide then
            part.CanCollide = false
        end
    end
    
    local function noclip()
        if not char or not char.Parent then return end
        
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") and part.CanCollide then
                part.CanCollide = false
            end
        end
    end
    
    local noClipLoop = RunService.Heartbeat:Connect(function()
        if not isNoClipping or not char or not char.Parent then
            return
        end
        noclip()
    end)
    
    table.insert(noClipConnections, noClipLoop)
    
    local function setupNoClipForPart(part)
        if part:IsA("BasePart") and part.CanCollide then
            part.CanCollide = false
        end
    end
    
    local descendantAdded = char.DescendantAdded:Connect(setupNoClipForPart)
    table.insert(noClipConnections, descendantAdded)
end

local function stopNoClip()
    isNoClipping = false
    
    local char = Players.LocalPlayer.Character
    if not char then return end
    
    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
    
    for _, connection in ipairs(noClipConnections) do
        if connection then
            if typeof(connection) == "RBXScriptConnection" then
                pcall(function() connection:Disconnect() end)
            elseif typeof(connection) == "Instance" then
                pcall(function() connection:Destroy() end)
            end
        end
    end
    noClipConnections = {}
end

local function startSpeedHack()
    local char = Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    
    isSpeedHacking = true
    local originalWalkSpeed = hum.WalkSpeed
    local originalJumpPower = hum.JumpPower
    
    hum.WalkSpeed = SpeedHackConfig.Speed * 16
    
    if SpeedHackConfig.UseJumpPower then
        hum.JumpPower = SpeedHackConfig.Speed * 50
    end
    
    local function onCharacterAdded(newChar)
        local newHum = newChar:WaitForChild("Humanoid")
        if isSpeedHacking then
            newHum.WalkSpeed = SpeedHackConfig.Speed * 16
            if SpeedHackConfig.UseJumpPower then
                newHum.JumpPower = SpeedHackConfig.Speed * 50
            end
        end
    end
    
    local characterAddedConnection = Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
    table.insert(speedHackConnections, characterAddedConnection)
    
    local speedLoop = RunService.Heartbeat:Connect(function()
        if not isSpeedHacking then return end
        
        local currentChar = Players.LocalPlayer.Character
        local currentHum = currentChar and currentChar:FindFirstChildOfClass("Humanoid")
        
        if currentHum then
            if currentHum.WalkSpeed ~= SpeedHackConfig.Speed * 16 then
                currentHum.WalkSpeed = SpeedHackConfig.Speed * 16
            end
            
            if SpeedHackConfig.UseJumpPower and currentHum.JumpPower ~= SpeedHackConfig.Speed * 50 then
                currentHum.JumpPower = SpeedHackConfig.Speed * 50
            end
        end
    end)
    
    table.insert(speedHackConnections, speedLoop)
end

local function stopSpeedHack()
    isSpeedHacking = false
    
    local char = Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.WalkSpeed = 16
        hum.JumpPower = 50
    end
    
    for _, connection in ipairs(speedHackConnections) do
        if connection then
            if typeof(connection) == "RBXScriptConnection" then
                pcall(function() connection:Disconnect() end)
            elseif typeof(connection) == "Instance" then
                pcall(function() connection:Destroy() end)
            end
        end
    end
    speedHackConnections = {}
end

local function startLongJump()
    local char = Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    
    isLongJumping = true
    local originalLongJumpPower = hum.JumpPower
    
    hum.JumpPower = LongJumpConfig.JumpPower
    
    local function onCharacterAdded(newChar)
        local newHum = newChar:WaitForChild("Humanoid")
        if isLongJumping then
            newHum.JumpPower = LongJumpConfig.JumpPower
        end
    end
    
    local characterAddedConnection = Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
    table.insert(longJumpConnections, characterAddedConnection)
    
    local longJumpLoop = RunService.Heartbeat:Connect(function()
        if not isLongJumping then return end
        
        local currentChar = Players.LocalPlayer.Character
        local currentHum = currentChar and currentChar:FindFirstChildOfClass("Humanoid")
        
        if currentHum and currentHum.JumpPower ~= LongJumpConfig.JumpPower then
            currentHum.JumpPower = LongJumpConfig.JumpPower
        end
    end)
    
    table.insert(longJumpConnections, longJumpLoop)
end

local function stopLongJump()
    isLongJumping = false
    
    local char = Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.JumpPower = 50
    end
    
    for _, connection in ipairs(longJumpConnections) do
        if connection then
            if typeof(connection) == "RBXScriptConnection" then
                pcall(function() connection:Disconnect() end)
            elseif typeof(connection) == "Instance" then
                pcall(function() connection:Destroy() end)
            end
        end
    end
    longJumpConnections = {}
end

local function startInfiniteJump()
    local char = Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not hum or not root then return end
    
    isInfiniteJumping = true
    local lastJumpTime = 0
    
    local function onJumpRequest()
        if not isInfiniteJumping then return end
        
        local currentTime = tick()
        if currentTime - lastJumpTime < 0.1 then return end
        
        lastJumpTime = currentTime
        
        local bv = Instance.new("BodyVelocity", root)
        bv.MaxForce = Vector3.new(0, math.huge, 0)
        bv.Velocity = Vector3.new(0, InfiniteJumpConfig.JumpPower, 0)
        
        task.spawn(function()
            task.wait(0.3)
            if bv and bv.Parent then
                bv:Destroy()
            end
        end)
    end
    
    local jumpConnection = hum.Jumping:Connect(onJumpRequest)
    table.insert(infiniteJumpConnections, jumpConnection)
    
    local function onInputBegan(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.Space then
            onJumpRequest()
        end
    end
    
    local inputConnection = UserInputService.InputBegan:Connect(onInputBegan)
    table.insert(infiniteJumpConnections, inputConnection)
    
    local function onCharacterAdded(newChar)
        if isInfiniteJumping then
            task.wait(1)
            startInfiniteJump()
        end
    end
    
    local characterAddedConnection = Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
    table.insert(infiniteJumpConnections, characterAddedConnection)
end

local function stopInfiniteJump()
    isInfiniteJumping = false
    lastJumpTime = 0
    
    for _, connection in ipairs(infiniteJumpConnections) do
        if connection then
            if typeof(connection) == "RBXScriptConnection" then
                pcall(function() connection:Disconnect() end)
            elseif typeof(connection) == "Instance" then
                pcall(function() connection:Destroy() end)
            end
        end
    end
    infiniteJumpConnections = {}
    
    local char = Players.LocalPlayer.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if root then
        for _, child in pairs(root:GetChildren()) do
            if child:IsA("BodyVelocity") then
                child:Destroy()
            end
        end
    end
end

-- Заглушки для функций, которые нужно реализовать
local function startYBA()
    if isYBAEnabled then return end
    isYBAEnabled = true
    YBAConfig.Enabled = true
    print("YBA started")
end

local function stopYBA()
    if not isYBAEnabled then return end
    isYBAEnabled = false
    YBAConfig.Enabled = false
    print("YBA stopped")
end

local function startUndergroundControl()
    if isUndergroundControlEnabled then return end
    isUndergroundControlEnabled = true
    print("Underground control started")
end

local function stopUndergroundControl()
    if not isUndergroundControlEnabled then return end
    isUndergroundControlEnabled = false
    print("Underground control stopped")
end

local function startItemESP()
    if YBAConfig.ItemESP.Enabled then return end
    YBAConfig.ItemESP.Enabled = true
    print("Item ESP started")
end

local function stopItemESP()
    if not YBAConfig.ItemESP.Enabled then return end
    YBAConfig.ItemESP.Enabled = false
    print("Item ESP stopped")
end

local function startTeleport()
    if not TeleportConfig.TargetPlayer then 
        print("Select player first!")
        return 
    end
    
    local char = Players.LocalPlayer.Character
    local targetChar = TeleportConfig.TargetPlayer.Character
    if not char or not targetChar then 
        print("Character not found!")
        return 
    end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
    if not root or not targetRoot then 
        print("HumanoidRootPart not found!")
        return 
    end
    
    isTeleporting = true
    TeleportConfig.OriginalPosition = root.Position
    
    if not isNoClipping then
        startNoClip()
    end
    
    local teleportLoop = RunService.Heartbeat:Connect(function()
        if not isTeleporting or not targetChar or not targetChar.Parent then
            return
        end
        
        local currentTargetRoot = targetChar:FindFirstChild("HumanoidRootPart")
        if currentTargetRoot then
            local targetPos = currentTargetRoot.Position
            local currentPos = root.Position
            local distance = (targetPos - currentPos).Magnitude
            
            local targetCFrame = currentTargetRoot.CFrame
            local behindPosition = targetCFrame * CFrame.new(0, 0, TeleportConfig.BehindPlayerDistance)
            
            local bv = root:FindFirstChild("BodyVelocity")
            if not bv then
                bv = Instance.new("BodyVelocity", root)
                bv.MaxForce = Vector3.new(1e6, 1e6, 1e6)
                bv.Velocity = Vector3.new(0, 0, 0)
            end
            
            local bg = root:FindFirstChild("BodyGyro")
            if not bg then
                bg = Instance.new("BodyGyro", root)
                bg.MaxTorque = Vector3.new(1e6, 1e6, 1e6)
                bg.D = 50
                bg.P = 1000
            end
            
            local targetLookVector = targetCFrame.LookVector
            bg.CFrame = CFrame.lookAt(root.Position, root.Position + targetLookVector)
            
            local targetVelocity = currentTargetRoot.Velocity
            local targetSpeed = targetVelocity.Magnitude
            
            local predictionTime = 0.1
            local predictedPosition = behindPosition.Position + (targetVelocity * predictionTime)
            local predictedDistance = (predictedPosition - currentPos).Magnitude
            
            local adaptiveSpeed = TeleportConfig.TeleportSpeed
            if targetSpeed > 80 then
                adaptiveSpeed = TeleportConfig.TeleportSpeed * 2.0
            elseif targetSpeed > 50 then
                adaptiveSpeed = TeleportConfig.TeleportSpeed * 1.5
            elseif targetSpeed > 20 then
                adaptiveSpeed = TeleportConfig.TeleportSpeed * 1.2
            end
            
            if predictedDistance > 1.5 then
                local direction = (predictedPosition - currentPos).Unit
                local currentVelocity = bv.Velocity
                local targetVelocity = direction * adaptiveSpeed
                
                local accelerationFactor = 0.15
                if targetSpeed > 80 then
                    accelerationFactor = 0.5
                elseif targetSpeed > 50 then
                    accelerationFactor = 0.4
                elseif targetSpeed > 30 then
                    accelerationFactor = 0.3
                end
                local velocityDiff = targetVelocity - currentVelocity
                local acceleration = velocityDiff * accelerationFactor
                
                bv.Velocity = currentVelocity + acceleration
            else
                local direction = (predictedPosition - currentPos).Unit
                local correctionSpeed = math.min(predictedDistance * 15, 30)
                
                if targetSpeed > 10 then
                    correctionSpeed = correctionSpeed * 1.5
                end
                
                bv.Velocity = direction * correctionSpeed
                
                if predictedDistance < 0.3 and targetSpeed < 5 then
                    bv.Velocity = Vector3.new(0, 0, 0)
                end
            end
        end
    end)
    
    table.insert(teleportConnections, teleportLoop)
end

local function stopTeleport()
    isTeleporting = false
    
    local char = Players.LocalPlayer.Character
    if not char then 
        return 
    end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChild("Humanoid")
    
    for _, connection in ipairs(teleportConnections) do
        if connection then
            if typeof(connection) == "RBXScriptConnection" then
                pcall(function() connection:Disconnect() end)
            end
        end
    end
    teleportConnections = {}
    
    local bv = root and root:FindFirstChild("BodyVelocity")
    if bv then
        bv.Velocity = Vector3.new(0, 0, 0)
        task.wait(0.1)
        bv:Destroy()
    end
    
    local bg = root and root:FindFirstChild("BodyGyro")
    if bg then
        bg:Destroy()
    end
    
    if humanoid then
        humanoid.WalkSpeed = 16
        humanoid.JumpPower = 50
    end
    
    if root and TeleportConfig.OriginalPosition then
        if not isNoClipping then
            startNoClip()
        end
        
        local returnConnections = {}
        
        local returnLoop = RunService.Heartbeat:Connect(function()
            if not root or not root.Parent then
                return
            end
            
            local currentPos = root.Position
            local returnPos = TeleportConfig.OriginalPosition
            local distance = (returnPos - currentPos).Magnitude
            
            if distance > 3 then
                local returnBv = root:FindFirstChild("BodyVelocity")
                if not returnBv then
                    returnBv = Instance.new("BodyVelocity", root)
                    returnBv.MaxForce = Vector3.new(1e6, 1e6, 1e6) 
                end
                
                local returnDirection = (returnPos - currentPos).Unit
                local returnSpeed = TeleportConfig.ReturnSpeed
                
                returnSpeed = returnSpeed + math.random(-5, 5)
                
                returnBv.Velocity = returnDirection * returnSpeed
            else
                local returnBv = root:FindFirstChild("BodyVelocity")
                if returnBv then
                    returnBv.Velocity = Vector3.new(0, 0, 0)
                    task.wait(0.5)
                    returnBv:Destroy()
                end
                
                local returnBg = root:FindFirstChild("BodyGyro")
                if returnBg then
                    returnBg:Destroy()
                end
                
                root.CFrame = CFrame.new(TeleportConfig.OriginalPosition)
                TeleportConfig.OriginalPosition = nil
                
                local freezeBv = Instance.new("BodyVelocity", root)
                freezeBv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
                freezeBv.Velocity = Vector3.new(0, 0, 0)
                
                task.wait(2)
                
                if freezeBv then
                    freezeBv:Destroy()
                end
                
                task.spawn(function()
                    task.wait(5)
                    if isNoClipping then
                        stopNoClip()
                    end
                end)
                
                for _, connection in ipairs(returnConnections) do
                    if connection then
                        pcall(function() connection:Disconnect() end)
                    end
                end
                
                if returnLoop then
                    returnLoop:Disconnect()
                end
            end
        end)
        
        table.insert(returnConnections, returnLoop)
    end
    
    local humanoid = char and char:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = 16
        humanoid.JumpPower = 50
    end
end

-- Main frame
local mainFrame = Instance.new("Frame", FrostwareGui)
mainFrame.Name = "MainFrame"
mainFrame.Position = UDim2.new(0, 60, 0.5, -220)
mainFrame.Size = UDim2.new(0, 420, 0, 440)
mainFrame.BackgroundColor3 = Color3.fromRGB(18, 18, 22)
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 12)

-- Hide/Show button
local showBtn = Instance.new("TextButton", FrostwareGui)
showBtn.Size = UDim2.new(0, 40, 0, 40)
showBtn.Position = UDim2.new(1, -60, 0, 20)
showBtn.AnchorPoint = Vector2.new(1, 0)
showBtn.Text = "≡"
showBtn.Font = Enum.Font.GothamBold
showBtn.TextSize = 24
showBtn.TextColor3 = Color3.fromRGB(220,220,240)
showBtn.BackgroundColor3 = Color3.fromRGB(24, 24, 32)
Instance.new("UICorner", showBtn).CornerRadius = UDim.new(1, 20)
showBtn.Visible = false

-- Скрытие/открытие меню
local function setMenuVisible(visible)
    mainFrame.Visible = visible
    showBtn.Visible = not visible
end
setMenuVisible(true)

-- Кнопка скрытия (крестик)
local closeBtn = Instance.new("TextButton", mainFrame)
closeBtn.Size = UDim2.new(0, 32, 0, 32)
closeBtn.Position = UDim2.new(1, -40, 0, -15)
closeBtn.Text = "×"
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextSize = 22
closeBtn.TextColor3 = Color3.fromRGB(220,100,100)
closeBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(1, 16)

closeBtn.MouseButton1Click:Connect(function()
    setMenuVisible(false)
end)
showBtn.MouseButton1Click:Connect(function()
    setMenuVisible(true)
end)

-- Поддержка клавиши Insert
UserInputService.InputBegan:Connect(function(input, gp)
    if not gp and input.KeyCode == Enum.KeyCode.Insert then
        setMenuVisible(not mainFrame.Visible)
    end
end)

-- Sidebar
local sidebar = Instance.new("Frame", mainFrame)
sidebar.Name = "Sidebar"
sidebar.Size = UDim2.new(0, 110, 1, 0)
sidebar.Position = UDim2.new(0, 0, 0, 0)
sidebar.BackgroundColor3 = Color3.fromRGB(24, 24, 32)
sidebar.BorderSizePixel = 0
Instance.new("UICorner", sidebar).CornerRadius = UDim.new(0, 12)

local tabList = Instance.new("Frame", sidebar)
tabList.Size = UDim2.new(1, 0, 1, 0)
tabList.BackgroundTransparency = 1

local tabLayout = Instance.new("UIListLayout", tabList)
tabLayout.SortOrder = Enum.SortOrder.LayoutOrder
tabLayout.Padding = UDim.new(0, 8)

-- Content frame
local contentFrame = Instance.new("Frame", mainFrame)
contentFrame.Name = "ContentFrame"
contentFrame.Position = UDim2.new(0, 110, 0, 0)
contentFrame.Size = UDim2.new(1, -110, 1, 0)
contentFrame.BackgroundTransparency = 1

-- Tabs
local tabs = {
    {name = "ESP", icon = "👁"},
    {name = "Aimbot", icon = "🎯"},
    {name = "Fly", icon = "🦅"},
    {name = "NoClip", icon = "🚪"},
    {name = "Speed", icon = "⚡"},
    {name = "Jump", icon = "🦘"},
    {name = "YBA", icon = "👊"},
    {name = "Teleport", icon = "📍"},
    {name = "Settings", icon = "⚙️"},
}

local tabButtons = {}
local tabFrames = {}
local tabContainers = {}

-- Helper: Toggle switch
local function createToggle(parent, label, state, callback)
    local row = Instance.new("Frame", parent)
    row.Size = UDim2.new(1, 0, 0, 36)
    row.BackgroundTransparency = 1

    local lbl = Instance.new("TextLabel", row)
    lbl.Text = label
    lbl.Size = UDim2.new(0.7, 0, 1, 0)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 14
    lbl.TextColor3 = Color3.new(1,1,1)
    lbl.BackgroundTransparency = 1
    lbl.TextXAlignment = Enum.TextXAlignment.Left

    local toggle = Instance.new("Frame", row)
    toggle.Size = UDim2.new(0, 44, 0, 22)
    toggle.Position = UDim2.new(1, -54, 0.5, -11)
    toggle.BackgroundColor3 = state and Color3.fromRGB(0, 200, 120) or Color3.fromRGB(60, 60, 60)
    toggle.BorderSizePixel = 0
    Instance.new("UICorner", toggle).CornerRadius = UDim.new(1, 11)

    local knob = Instance.new("Frame", toggle)
    knob.Size = UDim2.new(0, 18, 0, 18)
    knob.Position = state and UDim2.new(1, -20, 0.5, -9) or UDim2.new(0, 2, 0.5, -9)
    knob.BackgroundColor3 = Color3.fromRGB(240,240,240)
    knob.BorderSizePixel = 0
    Instance.new("UICorner", knob).CornerRadius = UDim.new(1, 9)

    local function setState(on)
        state = on
        toggle.BackgroundColor3 = on and Color3.fromRGB(0, 200, 120) or Color3.fromRGB(60, 60, 60)
        local newPos = on and UDim2.new(1, -20, 0.5, -9) or UDim2.new(0, 2, 0.5, -9)
        knob:TweenPosition(newPos, "Out", "Quad", 0.15, true)
        if callback then callback(on) end
    end

    row.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            setState(not state)
        end
    end)
    
    return row
end

-- Helper: Slider
local function createSlider(parent, label, min, max, value, callback)
    local row = Instance.new("Frame", parent)
    row.Size = UDim2.new(1, 0, 0, 38)
    row.BackgroundTransparency = 1

    local lbl = Instance.new("TextLabel", row)
    lbl.Text = label .. ": " .. value
    lbl.Size = UDim2.new(0.5, 0, 1, 0)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 13
    lbl.TextColor3 = Color3.new(1,1,1)
    lbl.BackgroundTransparency = 1
    lbl.TextXAlignment = Enum.TextXAlignment.Left

    local sliderBack = Instance.new("Frame", row)
    sliderBack.Position = UDim2.new(0.5, 10, 0.5, -7)
    sliderBack.Size = UDim2.new(0.45, -20, 0, 14)
    sliderBack.BackgroundColor3 = Color3.fromRGB(60,60,60)
    Instance.new("UICorner", sliderBack).CornerRadius = UDim.new(1,7)

    local sliderFill = Instance.new("Frame", sliderBack)
    sliderFill.Size = UDim2.new((value-min)/(max-min), 0, 1, 0)
    sliderFill.BackgroundColor3 = Color3.fromRGB(0, 200, 120)
    Instance.new("UICorner", sliderFill).CornerRadius = UDim.new(1,7)

    local dragging = false
    local connection
    
    local function updateSlider(input)
        local pos = input.Position.X
        local abs = sliderBack.AbsolutePosition.X
        local width = sliderBack.AbsoluteSize.X
        local pct = math.clamp((pos - abs) / width, 0, 1)
        local newVal = math.floor((min + (max - min) * pct) * 10) / 10
        sliderFill.Size = UDim2.new(pct, 0, 1, 0)
        lbl.Text = label .. ": " .. newVal
        if callback then callback(newVal) end
    end

    sliderBack.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            updateSlider(input)
            
            connection = UserInputService.InputChanged:Connect(function(input)
                if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                    updateSlider(input)
                end
            end)
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end)
    
    return row
end

-- Helper: Color picker
local function createColorPicker(parent, label, currentColor, callback)
    local row = Instance.new("Frame", parent)
    row.Size = UDim2.new(1, 0, 0, 32)
    row.BackgroundTransparency = 1

    local lbl = Instance.new("TextLabel", row)
    lbl.Text = label
    lbl.Size = UDim2.new(0.5, 0, 1, 0)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 13
    lbl.TextColor3 = Color3.new(1,1,1)
    lbl.BackgroundTransparency = 1
    lbl.TextXAlignment = Enum.TextXAlignment.Left

    local colorBtn = Instance.new("TextButton", row)
    colorBtn.Size = UDim2.new(0, 32, 0, 24)
    colorBtn.Position = UDim2.new(1, -40, 0.5, -12)
    colorBtn.BackgroundColor3 = currentColor
    colorBtn.Text = ""
    colorBtn.AutoButtonColor = true
    Instance.new("UICorner", colorBtn).CornerRadius = UDim.new(1, 12)

    local colors = {
        Color3.fromRGB(255, 255, 255),
        Color3.fromRGB(255, 0, 0),
        Color3.fromRGB(0, 255, 0),
        Color3.fromRGB(0, 0, 255),
        Color3.fromRGB(255, 255, 0),
        Color3.fromRGB(255, 0, 255),
        Color3.fromRGB(0, 255, 255),
        Color3.fromRGB(255, 165, 0),
        Color3.fromRGB(128, 0, 128),
        Color3.fromRGB(0, 128, 0),
    }

    local colorIndex = 1
    colorBtn.MouseButton1Click:Connect(function()
        colorIndex = (colorIndex % #colors) + 1
        local newColor = colors[colorIndex]
        colorBtn.BackgroundColor3 = newColor
        if callback then callback(newColor) end
    end)
    
    return row
end

-- Helper: Section header
local function sectionHeader(parent, text)
    local lbl = Instance.new("TextLabel", parent)
    lbl.Text = text
    lbl.Size = UDim2.new(1, 0, 0, 28)
    lbl.Font = Enum.Font.GothamBold
    lbl.TextSize = 15
    lbl.TextColor3 = Color3.fromRGB(180,180,200)
    lbl.BackgroundTransparency = 1
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    return lbl
end

-- Helper: Button
local function createButton(parent, text, callback)
    local btn = Instance.new("TextButton", parent)
    btn.Size = UDim2.new(1, 0, 0, 32)
    btn.Text = text
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 14
    btn.TextColor3 = Color3.new(1,1,1)
    btn.BackgroundColor3 = Color3.fromRGB(40,40,60)
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0,6)
    if callback then
        btn.MouseButton1Click:Connect(callback)
    end
    return btn
end

-- Create tabs
for i, tab in ipairs(tabs) do
    -- Tab button
    local btn = Instance.new("TextButton", tabList)
    btn.Size = UDim2.new(1, -16, 0, 38)
    btn.Text = tab.icon .. "  " .. tab.name
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 15
    btn.TextColor3 = Color3.fromRGB(220,220,240)
    btn.BackgroundColor3 = i == 1 and Color3.fromRGB(40, 40, 60) or Color3.fromRGB(30, 30, 40)
    btn.AutoButtonColor = false
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)
    tabButtons[tab.name] = btn

    -- Tab content frame
    local tabFrame = Instance.new("Frame", contentFrame)
    tabFrame.Name = tab.name .. "Tab"
    tabFrame.Size = UDim2.new(1, 0, 1, 0)
    tabFrame.BackgroundTransparency = 1
    tabFrame.Visible = (i == 1)
    tabFrames[tab.name] = tabFrame

    -- Scrolling frame
    local scrollFrame = Instance.new("ScrollingFrame", tabFrame)
    scrollFrame.Size = UDim2.new(1, 0, 1, 0)
    scrollFrame.Position = UDim2.new(0, 0, 0, 0)
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    scrollFrame.ScrollBarThickness = 6
    scrollFrame.BackgroundTransparency = 1
    scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
    scrollFrame.ClipsDescendants = true

    -- Container
    local container = Instance.new("Frame", scrollFrame)
    container.Size = UDim2.new(1, -20, 0, 0)
    container.Position = UDim2.new(0, 10, 0, 50)
    container.BackgroundTransparency = 1
    container.AutomaticSize = Enum.AutomaticSize.Y

    local layout = Instance.new("UIListLayout", container)
    layout.Padding = UDim2.new(0, 8)
    layout.SortOrder = Enum.SortOrder.LayoutOrder

    -- Tab switching
    btn.MouseButton1Click:Connect(function()
        for _, f in pairs(tabFrames) do f.Visible = false end
        for _, b in pairs(tabButtons) do b.BackgroundColor3 = Color3.fromRGB(30, 30, 40) end
        tabFrame.Visible = true
        btn.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    end)

    -- Store container
    tabContainers[tab.name] = container
end

-- === ESP TAB ===
local espContainer = tabContainers["ESP"]

createToggle(espContainer, "ESP", Config.ESP.Enabled, function(v) Config.ESP.Enabled = v end)
createToggle(espContainer, "Team Check", Config.ESP.TeamCheck, function(v) Config.ESP.TeamCheck = v end)
createToggle(espContainer, "Show Outline", Config.ESP.ShowOutline, function(v) Config.ESP.ShowOutline = v end)
createToggle(espContainer, "Show Lines", Config.ESP.ShowLines, function(v) Config.ESP.ShowLines = v end)
createToggle(espContainer, "Rainbow Colors", Config.ESP.Rainbow, function(v) Config.ESP.Rainbow = v end)
createColorPicker(espContainer, "Fill Color", Config.ESP.FillColor, function(c) Config.ESP.FillColor = c end)
createColorPicker(espContainer, "Outline Color", Config.ESP.OutlineColor, function(c) Config.ESP.OutlineColor = c end)
createColorPicker(espContainer, "Text Color", Config.ESP.TextColor, function(c) Config.ESP.TextColor = c end)
createSlider(espContainer, "Fill Transparency", 0, 1, Config.ESP.FillTransparency, function(v) Config.ESP.FillTransparency = v end)
createSlider(espContainer, "Outline Transparency", 0, 1, Config.ESP.OutlineTransparency, function(v) Config.ESP.OutlineTransparency = v end)

-- === AIMBOT TAB ===
local aimbotContainer = tabContainers["Aimbot"]

createToggle(aimbotContainer, "Aimbot", Config.Aimbot.Enabled, function(v) Config.Aimbot.Enabled = v end)
createToggle(aimbotContainer, "Team Check", Config.Aimbot.TeamCheck, function(v) Config.Aimbot.TeamCheck = v end)
createToggle(aimbotContainer, "Visibility Check", Config.Aimbot.VisibilityCheck, function(v) Config.Aimbot.VisibilityCheck = v end)
createSlider(aimbotContainer, "FOV Radius", 10, 500, Config.Aimbot.FOV, function(v) Config.Aimbot.FOV = v end)
createToggle(aimbotContainer, "FOV Rainbow", Config.Aimbot.FOVRainbow, function(v) Config.Aimbot.FOVRainbow = v end)
createColorPicker(aimbotContainer, "Aimbot FOV Color", Config.Aimbot.FOVColor, function(c) Config.Aimbot.FOVColor = c end)

-- === FLY TAB ===
local flyContainer = tabContainers["Fly"]

createToggle(flyContainer, "Fly", FlyConfig.Enabled, function(v) 
    FlyConfig.Enabled = v 
    if v then pcall(startFly) else pcall(stopFly) end 
end)
createSlider(flyContainer, "Fly Speed", 0.1, 10, FlyConfig.Speed, function(v) FlyConfig.Speed = v end)

-- === NOCLIP TAB ===
local noClipContainer = tabContainers["NoClip"]

createToggle(noClipContainer, "NoClip", NoClipConfig.Enabled, function(v) 
    NoClipConfig.Enabled = v 
    if v then pcall(startNoClip) else pcall(stopNoClip) end 
end)
createButton(noClipContainer, "Force NoClip Toggle", function()
    if isNoClipping then pcall(stopNoClip) else pcall(startNoClip) end
end)

-- === SPEED TAB ===
local speedContainer = tabContainers["Speed"]

createToggle(speedContainer, "SpeedHack", SpeedHackConfig.Enabled, function(v) 
    SpeedHackConfig.Enabled = v 
    if v then pcall(startSpeedHack) else pcall(stopSpeedHack) end 
end)
createToggle(speedContainer, "Use JumpPower Method", SpeedHackConfig.UseJumpPower, function(v) SpeedHackConfig.UseJumpPower = v end)
createSlider(speedContainer, "SpeedHack Speed", 0.1, 10, SpeedHackConfig.Speed, function(v) SpeedHackConfig.Speed = v end)

-- === JUMP TAB ===
local jumpContainer = tabContainers["Jump"]

createToggle(jumpContainer, "Long Jump", LongJumpConfig.Enabled, function(v) 
    LongJumpConfig.Enabled = v 
    if v then pcall(startLongJump) else pcall(stopLongJump) end 
end)
createSlider(jumpContainer, "Long Jump Power", 50, 500, LongJumpConfig.JumpPower, function(v) LongJumpConfig.JumpPower = v end)
createToggle(jumpContainer, "Infinite Jump", InfiniteJumpConfig.Enabled, function(v) 
    InfiniteJumpConfig.Enabled = v 
    if v then pcall(startInfiniteJump) else pcall(stopInfiniteJump) end 
end)
createSlider(jumpContainer, "Infinite Jump Power", 20, 150, InfiniteJumpConfig.JumpPower, function(v) InfiniteJumpConfig.JumpPower = v end)

-- === YBA TAB ===
local ybaContainer = tabContainers["YBA"]

createToggle(ybaContainer, "Stand Range Hack", YBAConfig.Enabled, function(v) 
    YBAConfig.Enabled = v 
    if v then pcall(startYBA) else pcall(stopYBA) end 
end)
createToggle(ybaContainer, "Underground Flight", false, function(v) 
    if v then pcall(startUndergroundControl) else pcall(stopUndergroundControl) end 
end)
createToggle(ybaContainer, "Item ESP", YBAConfig.ItemESP.Enabled, function(v) 
    YBAConfig.ItemESP.Enabled = v 
    if v then pcall(startItemESP) else pcall(stopItemESP) end 
end)
createSlider(ybaContainer, "Flight & Stand Speed", 25, 300, YBAConfig.UndergroundControl.FlightSpeed, function(v) YBAConfig.UndergroundControl.FlightSpeed = math.floor(v) end)

-- Item selection for YBA
sectionHeader(ybaContainer, "Item Selection")
local itemNames = {"Mysterious Arrow", "Rokakaka", "Pure Rokakaka", "Diamond", "Gold Coin", "Steel Ball", "Clackers", "Caesar's Headband", "Zeppeli's Hat", "Zeppeli's Scarf", "Quinton's Glove", "Stone Mask", "Rib Cage of The Saint's Corpse", "Ancient Scroll", "DIO's Diary", "DIO's Bone", "DIO's Diary Page", "Lucky Stone Mask", "Lucky Arrow"}

for _, itemName in ipairs(itemNames) do
    createToggle(ybaContainer, itemName, YBAConfig.ItemESP.Items[itemName], function(v) YBAConfig.ItemESP.Items[itemName] = v end)
end

-- === TELEPORT TAB ===
local teleportContainer = tabContainers["Teleport"]

createToggle(teleportContainer, "Teleport", TeleportConfig.Enabled, function(v) 
    TeleportConfig.Enabled = v 
    if v then pcall(startTeleport) else pcall(stopTeleport) end 
end)
createButton(teleportContainer, "Start Teleport", function()
    if not TeleportConfig.TargetPlayer then print("Select player first!") return end
    if TeleportConfig.Enabled then pcall(stopTeleport) TeleportConfig.Enabled = false else pcall(startTeleport) TeleportConfig.Enabled = true end
end)
createButton(teleportContainer, "Stop Teleport", function()
    if TeleportConfig.Enabled then pcall(stopTeleport) TeleportConfig.Enabled = false end
end)
createButton(teleportContainer, "Stop Return", function()
    if _G.returnConnections then
        for _, connection in ipairs(_G.returnConnections) do
            if connection then pcall(function() connection:Disconnect() end) end
        end
        _G.returnConnections = nil
    end
    if _G.returnLoop then pcall(function() _G.returnLoop:Disconnect() end) _G.returnLoop = nil end
    TeleportConfig.OriginalPosition = nil
end)

-- Player selection for teleport
sectionHeader(teleportContainer, "Player Selection")
local function createPlayerList(parent)
    local allPlayers = Players:GetPlayers()
    local alivePlayers = {}
    
    for _, player in ipairs(allPlayers) do
        if player and player ~= Players.LocalPlayer then
            table.insert(alivePlayers, player)
        end
    end
    
    table.sort(alivePlayers, function(a, b) return a.Name:lower() < b.Name:lower() end)
    
    for _, player in ipairs(alivePlayers) do
        local playerBtn = Instance.new("TextButton", parent)
        playerBtn.Size = UDim2.new(1, 0, 0, 30)
        playerBtn.Text = player.Name
        playerBtn.Font = Enum.Font.Gotham
        playerBtn.TextSize = 12
        playerBtn.TextColor3 = Color3.new(1,1,1)
        playerBtn.BackgroundColor3 = Color3.fromRGB(50,50,60)
        playerBtn.AutoButtonColor = false
        Instance.new("UICorner", playerBtn).CornerRadius = UDim.new(0,4)
        
        playerBtn.MouseButton1Click:Connect(function()
            TeleportConfig.TargetPlayer = player
            TeleportConfig.SelectedPlayerName = player.Name
            print("Selected player: " .. player.Name)
        end)
    end
end

createPlayerList(teleportContainer)

-- === SETTINGS TAB ===
local settingsContainer = tabContainers["Settings"]

createButton(settingsContainer, "Update Player List", function() print("Player list updated") end)

-- Hotkey settings
sectionHeader(settingsContainer, "Hotkeys")
createButton(settingsContainer, "ESP Hotkey: [" .. (Config.ESP.ToggleKey and tostring(Config.ESP.ToggleKey.Name) or "None") .. "]", function() end)
createButton(settingsContainer, "Aimbot Hotkey: [" .. (Config.Aimbot.ToggleKey and tostring(Config.Aimbot.ToggleKey.Name) or "None") .. "]", function() end)
createButton(settingsContainer, "Fly Hotkey: [" .. (FlyConfig.ToggleKey and tostring(FlyConfig.ToggleKey.Name) or "None") .. "]", function() end)
createButton(settingsContainer, "NoClip Hotkey: [" .. (NoClipConfig.ToggleKey and tostring(NoClipConfig.ToggleKey.Name) or "None") .. "]", function() end)
createButton(settingsContainer, "SpeedHack Hotkey: [" .. (SpeedHackConfig.ToggleKey and tostring(SpeedHackConfig.ToggleKey.Name) or "None") .. "]", function() end)
createButton(settingsContainer, "Teleport Hotkey: [" .. (TeleportConfig.ToggleKey and tostring(TeleportConfig.ToggleKey.Name) or "None") .. "]", function() end)
createButton(settingsContainer, "Stand Range Hack Hotkey: [" .. (YBAConfig.ToggleKey and tostring(YBAConfig.ToggleKey.Name) or "None") .. "]", function() end)
