if not game:IsLoaded() then game.Loaded:Wait() end


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")


local Config = {
    ESP = {
        Enabled     = true,
        TeamCheck   = false,
        ShowOutline = true,
        ShowLines   = false,
        Rainbow     = false,
        FillColor   = Color3.fromRGB(255,255,255),
        OutlineColor= Color3.fromRGB(255,255,255),
        TextColor   = Color3.fromRGB(255,255,255),
        LineColor   = Color3.fromRGB(255,255,255),
        FillTransparency    = 0.5,
        OutlineTransparency = 0,
        Font        = Enum.Font.SciFi,
        TeamColor   = Color3.fromRGB(0,255,0),
        EnemyColor  = Color3.fromRGB(255,0,0),
        ToggleKey   = nil,
    },
    Aimbot = {
        Enabled         = false,
        TeamCheck       = false,
        VisibilityCheck = true,
        FOV             = 150,
        ToggleKey       = nil,
        FOVColor        = Color3.fromRGB(255,128,128),
        FOVRainbow      = false,
    },
    MenuCollapsed = false,
}


local FlyConfig = {
    Enabled = false,
    Speed = 1,
    ToggleKey = nil,
}


local NoClipConfig = {
    Enabled = false,
    ToggleKey = nil,
    ForceToggleKey = nil,
}


local SpeedHackConfig = {
    Enabled = false,
    Speed = 1,
    ToggleKey = nil,
    UseJumpPower = false,
}

local LongJumpConfig = {
    Enabled = false,
    JumpPower = 150,
    ToggleKey = nil,
}

local InfiniteJumpConfig = {
    Enabled = false,
    JumpPower = 50,
    ToggleKey = nil,
}


local TeleportConfig = {
    Enabled = false,
    TargetPlayer = nil,
    OriginalPosition = nil,
    ToggleKey = nil,
    SelectedPlayerName = nil,
    UseStealthMode = true,
    TeleportSpeed = 1200,
    ReturnSpeed = 2000,
    BehindPlayerDistance = 3.0,
    StabilizationTime = 0.5,
    MaxSpeedResetTime = 2.0,
    SpeedResetThreshold = 50,
    InstantTurnSpeed = 600,
    SmoothingFactor = 0.15,
    MaxCorrectionSpeed = 300,
    StabilizationThreshold = 0.8,
}

local YBAConfig = {
    Enabled = false,
    ToggleKey = nil,
    StandRange = 100000, -- Увеличена дистанция ударов стенда
    FreezePlayer = true,
    SwitchCamera = true,
    TransferControl = true,
    AutoFindStands = true,
    MaxStandDistance = 10000, -- Увеличена дистанция захвата стенда
    CameraDistance = 15,
    CameraHeight = 5,
    StandControlSpeed = 1.0,
    StandControlSmoothing = 0.1,
    MouseSensitivity = 0.01,
    CameraSmoothing = 0.08,
    CameraFollowDistance = 20.2,
    CameraFollowHeight = 6.1,
    MouseLookSensitivity = 0.003,
    StandRotationSpeed = 0.05,
    -- Item ESP Configuration
    ItemESP = {
        Enabled = false,
        ToggleKey = nil,
        MaxDistance = 1000, 
        MaxRenderDistance = 5000,
        UpdateInterval = 0.3,
        
        ShowOutline = true,
        ShowText = true,
        ShowFill = true,
        
        FillColor = Color3.fromRGB(255, 215, 0), -- Цвет заполнения предмета
        OutlineColor = Color3.fromRGB(255, 255, 0), -- Цвет обводки предмета
        TextColor = Color3.fromRGB(255, 255, 255), -- Цвет текста
        TextBackgroundColor = Color3.fromRGB(0, 0, 0), -- Цвет фона текста
        
        FillTransparency = 0.3, -- Прозрачность заполнения
        OutlineTransparency = 0.1, -- Прозрачность обводки
        TextBackgroundTransparency = 0.3, -- Прозрачность фона текста
        
        TextSize = 10, -- Размер основного текста
        DistanceTextSize = 9, -- Размер текста расстояния
        
        Font = Enum.Font.GothamBold,
        
        Items = {
            -- Основные предметы
            ["Mysterious Arrow"] = true,
            ["Rokakaka"] = true,
            ["Pure Rokakaka"] = true,
            ["Diamond"] = true,
            ["Gold Coin"] = true,
            ["Steel Ball"] = true,
            ["Clackers"] = true,
            ["Caesar's Headband"] = true,
            ["Zeppeli's Hat"] = true,
            ["Zeppeli's Scarf"] = true,
            ["Ancient Scroll"] = true,
            ["Quinton's Glove"] = true,
            ["Stone Mask"] = true,
            ["Lucky Arrow"] = true,
            ["Lucky Stone Mask"] = true,
            
            ["Rib Cage of The Saint's Corpse"] = true,
            
            ["DIO's Diary"] = true,
            ["DIO's Bone"] = true,
            ["DIO's Diary Page"] = true,
            

        }
    }
}

local AntiTimeStopConfig = {
    Enabled = false,
    ToggleKey = nil,
    MovementSpeed = 1.5, -- Скорость движения в остановленном времени
    JumpPower = 50, -- Сила прыжка в остановленном времени
    WalkSpeed = 16, -- Скорость ходьбы в остановленном времени
    AutoActivate = true, -- Автоматически активировать при обнаружении time stop
    DetectionRange = 100, -- Дистанция обнаружения time stop
    VisualEffect = true, -- Визуальный эффект при активации
    SoundEffect = false, -- Звуковой эффект при активации
    AntiFreeze = true, -- Предотвращать заморозку персонажа
    TimeStopBypass = true, -- Обходить остановку времени
    MovementOverride = true, -- Переопределять движение в time stop
    DisableOnAttack = true, -- Отключать BodyVelocity при атаке
    ServerSync = true, -- Синхронизировать с сервером
}

local isFlying = false
local flyConnections = {}
local originalGravity = workspace.Gravity

local isNoClipping = false
local noClipConnections = {}

local isSpeedHacking = false
local speedHackConnections = {}
local originalWalkSpeed = 16
local originalJumpPower = 50

local isLongJumping = false
local longJumpConnections = {}
local originalLongJumpPower = 50

local isInfiniteJumping = false
local infiniteJumpConnections = {}
local lastJumpTime = 0

local isTeleporting = false
local teleportConnections = {}
local playerSelectionWindow = nil
local lastTeleportPosition = nil
local stabilizationStartTime = nil
local isStabilizing = false
local speedResetTimer = 0
local lastSpeedCheck = tick()
local lastBehindDistance = 0

local isYBAEnabled = false
local ybaConnections = {}
local originalPlayerPosition = nil
local originalPlayerCFrame = nil
local originalCameraCFrame = nil
local controlledStand = nil
local standControlConnections = {}
local originalGravity = workspace.Gravity
local originalYBAWalkSpeed = 16
local originalYBAJumpPower = 50

local isAntiTimeStopEnabled = false
local antiTimeStopConnections = {}
local originalAntiTimeStopWalkSpeed = 16
local originalAntiTimeStopJumpPower = 50
local timeStopDetected = false
local timeStopStartTime = 0
local timeStopDuration = 0
local antiTimeStopEffect = nil

local isStandControlActive = false
local currentControlledStand = nil
local standCameraConnections = {}
local originalStandCameraCFrame = nil
local standControlActive = false

local freeCameraActive = false
local freeCameraConnections = {}
local freeCameraRotation = Vector2.new(0, 0)
local freeCameraDistance = 10
local freeCameraHeight = 5
local freeCameraTarget = nil
local freeCameraLastMousePos = Vector2.new(0, 0)
local lastCameraUpdate = nil

local itemESPConnections = {}
local itemESPElements = {}
local itemESPEnabled = false

local YBAFreeCamera = {} do
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local ContextActionService = game:GetService("ContextActionService")
    local Camera = workspace.CurrentCamera

    local fcRunning = false
    local INPUT_PRIORITY = Enum.ContextActionPriority.High.Value

    local cameraPos = Vector3.new()
    local cameraRot = Vector2.new()
    local cameraFov = 70
    local targetStand = nil
    local originalCameraCFrame = nil
    local cameraDistance = 10 -- Расстояние от камеры до стенда
    local cameraHeight = 5   -- Высота камеры над стендом

    local NAV_SPEED = 1

    local input = {
        W = 0, A = 0, S = 0, D = 0,
        Space = 0, LeftControl = 0,
        Up = 0, Down = 0,
        MouseDelta = Vector2.new(),
        MouseWheel = 0
    }

    local function onKey(actionName, inputState, inputObj)
        input[inputObj.KeyCode.Name] = (inputState == Enum.UserInputState.Begin) and 1 or 0
        return Enum.ContextActionResult.Sink
    end

    local function onMouse(actionName, inputState, inputObj)
        input.MouseDelta = Vector2.new(-inputObj.Delta.y, -inputObj.Delta.x)
        return Enum.ContextActionResult.Sink
    end

    local function onMouseWheel(actionName, inputState, inputObj)
        if inputObj.UserInputType == Enum.UserInputType.MouseWheel then
            input.MouseWheel = -inputObj.Position.Z
        end
        return Enum.ContextActionResult.Sink
    end

    local function startInput()
        for _, key in pairs({"W", "A", "S", "D", "Space", "LeftControl", "Up", "Down"}) do
            ContextActionService:BindActionAtPriority("FreecamKey_"..key, onKey, false, INPUT_PRIORITY, Enum.KeyCode[key])
        end
        ContextActionService:BindActionAtPriority("FreecamMouse", onMouse, false, INPUT_PRIORITY, Enum.UserInputType.MouseMovement)
        ContextActionService:BindActionAtPriority("FreecamMouseWheel", onMouseWheel, false, INPUT_PRIORITY, Enum.UserInputType.MouseWheel)
    end

    local function stopInput()
        for k in pairs(input) do
            if typeof(input[k]) == "number" then input[k] = 0 end
        end
        input.MouseDelta = Vector2.new()
        input.MouseWheel = 0
        ContextActionService:UnbindAction("FreecamMouse")
        ContextActionService:UnbindAction("FreecamMouseWheel")
        for _, key in pairs({"W", "A", "S", "D", "Space", "LeftControl", "Up", "Down"}) do
            ContextActionService:UnbindAction("FreecamKey_"..key)
        end
    end

    local function stepFreecam(dt)
        if not targetStand or not targetStand.Root or not targetStand.Root.Parent then
            return
        end

        local standRoot = targetStand.Root
        local standPosition = standRoot.Position

        local moveX = input.D - input.A
        local moveZ = input.S - input.W
        local moveY = input.Space - input.LeftControl -- Включено управление высотой стенда
        
        local move = Vector3.new(moveX, moveY, moveZ) * NAV_SPEED

        local bv = standRoot:FindFirstChild("BodyVelocity")
        if not bv then
            bv = Instance.new("BodyVelocity", standRoot)
            bv.MaxForce = Vector3.new(1e6, 1e6, 1e6)
        end
        
        if move.Magnitude > 0 then
            local cameraCFrame = CFrame.new(standPosition) * CFrame.Angles(0, cameraRot.Y, 0)
            local worldMove = cameraCFrame:VectorToWorldSpace(move)
            bv.Velocity = worldMove * 30 -- Уменьшена скорость для лучшего контроля

            if moveY ~= 0 then
                print("YBA: Стенд движется по вертикали: " .. (moveY > 0 and "вверх" or "вниз"))
            end
        else
            bv.Velocity = Vector3.new(0, 0, 0)
        end

        local pan = input.MouseDelta * math.rad(0.8) -- Уменьшена чувствительность для плавности
        input.MouseDelta = Vector2.new()

        if input.MouseWheel ~= 0 then
            cameraDistance = math.clamp(cameraDistance + input.MouseWheel * 1.5, 3, 20)
            input.MouseWheel = 0
        end

        cameraRot = cameraRot + pan
        cameraRot = Vector2.new(math.clamp(cameraRot.X, -math.rad(80), math.rad(80)), cameraRot.Y % (2 * math.pi))

        local player = Players.LocalPlayer
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local playerRoot = player.Character.HumanoidRootPart
            local humanoid = player.Character:FindFirstChild("Humanoid")
            
            if humanoid then
                local targetCFrame = CFrame.new(playerRoot.Position) * CFrame.Angles(0, cameraRot.Y, 0)
                playerRoot.CFrame = targetCFrame

                humanoid.AutoRotate = false
            end
        end

        local rot = CFrame.Angles(0, cameraRot.Y, 0) * CFrame.Angles(cameraRot.X, 0, 0)
        local cameraOffset = Vector3.new(0, cameraHeight - 2, cameraDistance) 
        local cf = CFrame.new(standPosition) * rot * CFrame.new(cameraOffset)

        cameraPos = cf.Position
        Camera.CFrame = cf
    end

    function YBAFreeCamera.Start(stand)
        if fcRunning then 
            YBAFreeCamera.Stop() 
        end
        
        if not stand or not stand.Root then
            print("YBA: Ошибка - стенд не найден")
            return false
        end
        
        targetStand = stand
        originalCameraCFrame = Camera.CFrame
        
        local standPosition = stand.Root.Position
        cameraPos = standPosition + Vector3.new(0, cameraHeight - 2, cameraDistance) 
        cameraRot = Vector2.new()
        cameraFov = Camera.FieldOfView

        local player = Players.LocalPlayer
        if player and player.Character then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.AutoRotate = false 
            end
        end
        
        Camera.CameraType = Enum.CameraType.Scriptable
        RunService:BindToRenderStep("YBAFreecam", Enum.RenderPriority.Camera.Value, stepFreecam)
        startInput()
        fcRunning = true
        
        print("YBA: Управление стендом активировано: " .. stand.Name)
        return true
    end

    function YBAFreeCamera.Stop()
        if not fcRunning then return end
        stopInput()
        RunService:UnbindFromRenderStep("YBAFreecam")
        Camera.CameraType = Enum.CameraType.Custom

        if targetStand and targetStand.Root then
            local bv = targetStand.Root:FindFirstChild("BodyVelocity")
            if bv then
                bv:Destroy()
            end
        end

        local player = Players.LocalPlayer
        if player and player.Character then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.AutoRotate = true
            end
        end
        
        if originalCameraCFrame then
            Camera.CFrame = originalCameraCFrame
        end
        
        targetStand = nil
        originalCameraCFrame = nil
        fcRunning = false
        
        print("YBA: Управление стендом отключено")
    end

    function YBAFreeCamera.Toggle(stand)
        if fcRunning then
            YBAFreeCamera.Stop()
            return false
        else
            return YBAFreeCamera.Start(stand)
        end
    end
end

local function startFly()
    local plr = Players.LocalPlayer
    local char = plr.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local root = char and char:FindFirstChild("HumanoidRootPart")
    
    if not hum or not root then return end
    
    isFlying = true
    
    local flyOriginalJumpPower = hum.JumpPower
    local flyOriginalJumpHeight = hum.JumpHeight
    local flyOriginalGravity = workspace.Gravity
    local flyOriginalHipHeight = hum.HipHeight
    
    hum.JumpPower = 0
    hum.JumpHeight = 0
    workspace.Gravity = 0
    hum.HipHeight = 0
    
    local ctrl = {f = 0, b = 0, l = 0, r = 0, u = 0, d = 0}
    
    local inputDown = UserInputService.InputBegan:Connect(function(input, gp)
        if gp then return end
        if input.KeyCode == Enum.KeyCode.W then ctrl.f = 1
        elseif input.KeyCode == Enum.KeyCode.S then ctrl.b = -1
        elseif input.KeyCode == Enum.KeyCode.A then ctrl.l = -1
        elseif input.KeyCode == Enum.KeyCode.D then ctrl.r = 1
        elseif input.KeyCode == Enum.KeyCode.Space then ctrl.u = 1
        elseif input.KeyCode == Enum.KeyCode.LeftControl then ctrl.d = -1 end
    end)
    
    local inputUp = UserInputService.InputEnded:Connect(function(input, gp)
        if gp then return end
        if input.KeyCode == Enum.KeyCode.W then ctrl.f = 0
        elseif input.KeyCode == Enum.KeyCode.S then ctrl.b = 0
        elseif input.KeyCode == Enum.KeyCode.A then ctrl.l = 0
        elseif input.KeyCode == Enum.KeyCode.D then ctrl.r = 0
        elseif input.KeyCode == Enum.KeyCode.Space then ctrl.u = 0
        elseif input.KeyCode == Enum.KeyCode.LeftControl then ctrl.d = 0 end
    end)
    
    local renderConnection = RunService.RenderStepped:Connect(function()
        if not isFlying or not char or not char:FindFirstChild("Humanoid") or not root then
            if hum then
                hum.JumpPower = flyOriginalJumpPower
                hum.JumpHeight = flyOriginalJumpHeight
                hum.HipHeight = flyOriginalHipHeight
            end
            if not isNoClipping then
                workspace.Gravity = flyOriginalGravity
            end
            
            inputDown:Disconnect()
            inputUp:Disconnect()
            renderConnection:Disconnect()
            return
        end
        
        local cam = workspace.CurrentCamera
        if not cam then return end
        
        
        local forward = cam.CFrame.lookVector
        local right = cam.CFrame.rightVector
        local up = Vector3.new(0, 1, 0)
        
        local moveVector = Vector3.new(0, 0, 0)
        moveVector = moveVector + (forward * (ctrl.f + ctrl.b))
        moveVector = moveVector + (right * (ctrl.r + ctrl.l))
        moveVector = moveVector + (up * (ctrl.u + ctrl.d))
        
        if moveVector.Magnitude > 0 then
            moveVector = moveVector.Unit * (FlyConfig.Speed * 10)
            local bv = root:FindFirstChild("BodyVelocity")
            if not bv then
                bv = Instance.new("BodyVelocity", root)
                bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
            end
            bv.Velocity = moveVector
        else
            local bv = root:FindFirstChild("BodyVelocity")
            if bv then
                bv.Velocity = Vector3.new(0, 0, 0)
            end
        end
    end)
    
    table.insert(flyConnections, inputDown)
    table.insert(flyConnections, inputUp)
    table.insert(flyConnections, renderConnection)
end

local function stopFly()
    isFlying = false
    
    local char = Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local root = char and char:FindFirstChild("HumanoidRootPart")
    
    if hum then
        
        hum.JumpPower = 50
        hum.JumpHeight = 7.2
        hum.HipHeight = 2
    end
    
    workspace.Gravity = 196.2
    
    
    if root then
        local bv = root:FindFirstChild("BodyVelocity")
        if bv then
            bv:Destroy()
        end
    end
    
    
    for _, connection in ipairs(flyConnections) do
        if connection then
            pcall(function() connection:Disconnect() end)
        end
    end
    flyConnections = {}
end

-- Anti Time Stop Functions
local function detectTimeStop()
    local players = Players:GetPlayers()
    local localPlayer = Players.LocalPlayer
    local localChar = localPlayer.Character
    local localRoot = localChar and localChar:FindFirstChild("HumanoidRootPart")
    
    if not localRoot then return false end
    
    -- Проверяем всех игроков на наличие time stop способностей
    for _, player in pairs(players) do
        if player ~= localPlayer then
            local char = player.Character
            if char then
                -- Проверяем стенд
                local stand = char:FindFirstChild("Stand")
                if stand then
                    -- Проверяем наличие time stop способностей
                    local standAbilities = stand:FindFirstChild("Abilities")
                    if standAbilities then
                        for _, ability in pairs(standAbilities:GetChildren()) do
                            local abilityName = ability.Name:lower()
                            if abilityName:find("time") or 
                               abilityName:find("stop") or
                               abilityName:find("za warudo") or
                               abilityName:find("the world") or
                               abilityName:find("timestop") or
                               abilityName:find("time_stop") or
                               abilityName:find("za") or
                               abilityName:find("warudo") then
                                return true, player, ability
                            end
                        end
                    end
                    
                    -- Дополнительная проверка для других возможных названий
                    local standName = stand.Name:lower()
                    if standName:find("the world") or 
                       standName:find("za warudo") or
                       standName:find("dio") or
                       standName:find("jotaro") or
                       standName:find("star platinum") or
                       standName:find("the world") then
                        return true, player, stand
                    end
                end
                
                -- Проверяем все части персонажа на наличие time stop эффектов
                for _, part in pairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        local partName = part.Name:lower()
                        if partName:find("time") or 
                           partName:find("stop") or
                           partName:find("freeze") or
                           partName:find("timestop") then
                            return true, player, part
                        end
                    end
                end
            end
        end
    end
    
    -- Дополнительная проверка: если игрок заморожен, возможно это time stop
    if localChar then
        local hum = localChar:FindFirstChildOfClass("Humanoid")
        if hum then
            -- Проверяем, не заморожен ли игрок
            for _, part in pairs(localChar:GetDescendants()) do
                if part:IsA("BasePart") and part.Anchored then
                    -- Если часть заморожена, возможно это time stop
                    return true, nil, nil
                end
            end
        end
    end
    
    return false
end

local function createAntiTimeStopEffect()
    if not AntiTimeStopConfig.VisualEffect then return end
    
    local char = Players.LocalPlayer.Character
    if not char then return end
    
    -- Создаем зеленую обводку персонажа
    local highlight = Instance.new("Highlight")
    highlight.Name = "AntiTimeStopEffect"
    highlight.FillColor = Color3.fromRGB(0, 255, 0) -- Зеленый цвет
    highlight.OutlineColor = Color3.fromRGB(0, 200, 0) -- Темно-зеленый контур
    highlight.FillTransparency = 0.3
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = char
    
    antiTimeStopEffect = highlight
end

local function removeAntiTimeStopEffect()
    if antiTimeStopEffect then
        antiTimeStopEffect:Destroy()
        antiTimeStopEffect = nil
    end
end

local function startAntiTimeStop()
    local plr = Players.LocalPlayer
    local char = plr.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local root = char and char:FindFirstChild("HumanoidRootPart")
    
    if not hum or not root then return end
    
    isAntiTimeStopEnabled = true
    timeStopDetected = false
    
    -- Сохраняем оригинальные значения
    originalAntiTimeStopWalkSpeed = hum.WalkSpeed
    originalAntiTimeStopJumpPower = hum.JumpPower
    
    -- Устанавливаем значения для anti time stop
    hum.WalkSpeed = AntiTimeStopConfig.WalkSpeed * AntiTimeStopConfig.MovementSpeed
    hum.JumpPower = AntiTimeStopConfig.JumpPower
    
    createAntiTimeStopEffect()
    
    -- Агрессивная защита от заморозки
    local antiFreezeLoop = RunService.Heartbeat:Connect(function()
        if not isAntiTimeStopEnabled or not char or not char.Parent then
            return
        end
        
        -- Принудительно разблокируем все части персонажа
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = false
                part.CanCollide = true
            end
        end
        
        -- Убеждаемся что Humanoid активен
        if hum then
            hum.WalkSpeed = AntiTimeStopConfig.WalkSpeed * AntiTimeStopConfig.MovementSpeed
            hum.JumpPower = AntiTimeStopConfig.JumpPower
            hum.AutoRotate = true
            hum.AutoJumpEnabled = true
        end
        
        -- Автоматическая активация при обнаружении заморозки
        if AntiTimeStopConfig.AutoActivate then
            local isFrozen = false
            for _, part in pairs(char:GetDescendants()) do
                if part:IsA("BasePart") and part.Anchored then
                    isFrozen = true
                    break
                end
            end
            
            if isFrozen and not timeStopDetected then
                timeStopDetected = true
                timeStopStartTime = tick()
                print("Auto-detected freeze! Activating Anti Time Stop...")
                
                -- Принудительно разблокируем
                for _, part in pairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.Anchored = false
                        part.CanCollide = true
                    end
                end
            end
        end
    end)
    
    -- Обработка атак для предотвращения конфликтов (отключено для безопасности)
    local attackDetection = RunService.Heartbeat:Connect(function()
        if not isAntiTimeStopEnabled or not timeStopDetected or not char or not char.Parent then
            return
        end
        
        -- Отключено для предотвращения смерти при атаке
        -- Проверяем только нажатие клавиш атаки для визуального эффекта
        local isAttacking = false
        
        if UserInputService:IsKeyDown(Enum.KeyCode.F) or 
           UserInputService:IsKeyDown(Enum.KeyCode.E) or
           UserInputService:IsKeyDown(Enum.KeyCode.R) or
           UserInputService:IsKeyDown(Enum.KeyCode.T) or
           UserInputService:IsKeyDown(Enum.KeyCode.Y) or
           UserInputService:IsKeyDown(Enum.KeyCode.Q) then
            isAttacking = true
        end
        
        -- Только визуальный эффект при атаке
        if isAttacking and antiTimeStopEffect then
            antiTimeStopEffect.FillColor = Color3.fromRGB(255, 255, 0) -- Желтый при атаке
        else
            if antiTimeStopEffect then
                antiTimeStopEffect.FillColor = Color3.fromRGB(0, 255, 0) -- Зеленый обычно
            end
        end
    end)
    
    -- Основной цикл обнаружения и обработки time stop
    local timeStopDetection = RunService.Heartbeat:Connect(function()
        if not isAntiTimeStopEnabled or not char or not char.Parent then
            return
        end
        
        local detected, timeStopPlayer, timeStopAbility = detectTimeStop()
        
        if detected and not timeStopDetected then
            timeStopDetected = true
            timeStopStartTime = tick()
            
            print("Time Stop detected! Activating Anti Time Stop...")
            
            -- Активируем защиту от time stop
            if AntiTimeStopConfig.AntiFreeze then
                -- Принудительно разблокируем персонажа
                for _, part in pairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.Anchored = false
                        part.CanCollide = true
                    end
                end
            end
            
            if AntiTimeStopConfig.MovementOverride then
                -- Переопределяем движение в time stop
                hum.WalkSpeed = AntiTimeStopConfig.WalkSpeed * AntiTimeStopConfig.MovementSpeed
                hum.JumpPower = AntiTimeStopConfig.JumpPower
                
                -- Создаем BodyVelocity для принудительного движения
                local bv = root:FindFirstChild("AntiTimeStopBodyVelocity")
                if not bv then
                    bv = Instance.new("BodyVelocity", root)
                    bv.Name = "AntiTimeStopBodyVelocity"
                    bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
                end
                
                -- Создаем BodyGyro для стабилизации
                local bg = root:FindFirstChild("AntiTimeStopBodyGyro")
                if not bg then
                    bg = Instance.new("BodyGyro", root)
                    bg.Name = "AntiTimeStopBodyGyro"
                    bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
                    bg.D = 1000
                    bg.P = 2000
                end
            end
            
            if AntiTimeStopConfig.SoundEffect then
                -- Воспроизводим звуковой эффект
                local sound = Instance.new("Sound", root)
                sound.SoundId = "rbxasset://sounds/electronicpingshort.wav"
                sound.Volume = 0.5
                sound:Play()
                game:GetService("Debris"):AddItem(sound, 2)
            end
            
        elseif not detected and timeStopDetected then
            timeStopDetected = false
            timeStopDuration = tick() - timeStopStartTime
            
            print("Time Stop ended. Duration: " .. timeStopDuration .. " seconds")
            
            -- Восстанавливаем нормальное состояние
            hum.WalkSpeed = originalAntiTimeStopWalkSpeed
            hum.JumpPower = originalAntiTimeStopJumpPower
            
            -- Удаляем BodyVelocity и BodyGyro
            local bv = root:FindFirstChild("AntiTimeStopBodyVelocity")
            if bv then
                bv:Destroy()
            end
            
            local bg = root:FindFirstChild("AntiTimeStopBodyGyro")
            if bg then
                bg:Destroy()
            end
            
            removeAntiTimeStopEffect()
        end
    end)
    
    -- Обработка движения в time stop
    local movementOverride = RunService.Heartbeat:Connect(function()
        if not isAntiTimeStopEnabled or not timeStopDetected or not char or not char.Parent then
            return
        end
        
        if AntiTimeStopConfig.MovementOverride then
            local bv = root:FindFirstChild("AntiTimeStopBodyVelocity")
            local bg = root:FindFirstChild("AntiTimeStopBodyGyro")
            
            if bv and bg then
                -- Обрабатываем ввод для движения
                local moveVector = Vector3.new(0, 0, 0)
                local cam = workspace.CurrentCamera
                
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                    moveVector = moveVector + cam.CFrame.lookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                    moveVector = moveVector - cam.CFrame.lookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                    moveVector = moveVector - cam.CFrame.rightVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                    moveVector = moveVector + cam.CFrame.rightVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                    moveVector = moveVector + Vector3.new(0, 1, 0)
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                    moveVector = moveVector - Vector3.new(0, 1, 0)
                end
                
                if moveVector.Magnitude > 0 then
                    moveVector = moveVector.Unit * (AntiTimeStopConfig.WalkSpeed * AntiTimeStopConfig.MovementSpeed)
                    bv.Velocity = moveVector
                    
                    -- Стабилизируем поворот
                    bg.CFrame = cam.CFrame
                    
                    -- Синхронизируем с сервером через изменение позиции
                    if AntiTimeStopConfig.ServerSync then
                        local newCFrame = root.CFrame + (moveVector * 0.016) -- 60 FPS
                        root.CFrame = newCFrame
                        
                        -- Альтернативный метод через RemoteEvent
                        local remoteEvent = game:GetService("ReplicatedStorage"):FindFirstChild("AntiTimeStopMovement")
                        if not remoteEvent then
                            remoteEvent = Instance.new("RemoteEvent")
                            remoteEvent.Name = "AntiTimeStopMovement"
                            remoteEvent.Parent = game:GetService("ReplicatedStorage")
                        end
                        
                        -- Отправляем позицию на сервер
                        remoteEvent:FireServer(newCFrame)
                    end
                    
                    -- Добавляем небольшой эффект для визуализации движения в time stop
                    if AntiTimeStopConfig.VisualEffect and antiTimeStopEffect then
                        antiTimeStopEffect.FillColor = Color3.fromRGB(0, 255, 255) -- Голубой цвет при движении
                    end
                else
                    bv.Velocity = Vector3.new(0, 0, 0)
                    
                    -- Возвращаем обычный цвет эффекта
                    if AntiTimeStopConfig.VisualEffect and antiTimeStopEffect then
                        antiTimeStopEffect.FillColor = Color3.fromRGB(0, 255, 0) -- Зеленый цвет
                    end
                end
            end
        end
    end)
    
    -- Обработчик событий для предотвращения смерти (отключено для безопасности)
    local damageProtection = char.Humanoid.Died:Connect(function()
        -- Отключено для предотвращения конфликтов с системой боя
    end)
    
    -- Обработчик изменения здоровья (отключено для безопасности)
    local healthChanged = hum.HealthChanged:Connect(function(health)
        -- Отключено для предотвращения конфликтов с системой боя
    end)
    
    table.insert(antiTimeStopConnections, antiFreezeLoop)
    table.insert(antiTimeStopConnections, attackDetection)
    table.insert(antiTimeStopConnections, timeStopDetection)
    table.insert(antiTimeStopConnections, movementOverride)
    table.insert(antiTimeStopConnections, damageProtection)
    table.insert(antiTimeStopConnections, healthChanged)
end

local function stopAntiTimeStop()
    isAntiTimeStopEnabled = false
    timeStopDetected = false
    
    local char = Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local root = char and char:FindFirstChild("HumanoidRootPart")
    
    if hum then
        hum.WalkSpeed = originalAntiTimeStopWalkSpeed
        hum.JumpPower = originalAntiTimeStopJumpPower
        hum.AutoRotate = true
        hum.AutoJumpEnabled = true
    end
    
    if root then
        local bv = root:FindFirstChild("AntiTimeStopBodyVelocity")
        if bv then
            bv:Destroy()
        end
        
        local bg = root:FindFirstChild("AntiTimeStopBodyGyro")
        if bg then
            bg:Destroy()
        end
    end
    
    removeAntiTimeStopEffect()
    
    for _, connection in ipairs(antiTimeStopConnections) do
        if connection then
            pcall(function() connection:Disconnect() end)
        end
    end
    antiTimeStopConnections = {}
    
    print("Anti Time Stop disabled")
end


local function startNoClip()
    local char = Players.LocalPlayer.Character
    if not char then return end
    
    isNoClipping = true
    
    
    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") and part.CanCollide then
            part.CanCollide = false
        end
    end
    
    
    local function noclip()
        if not char or not char.Parent then return end
        
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") and part.CanCollide then
                part.CanCollide = false
            end
        end
    end
    
    
    local noClipLoop = RunService.Heartbeat:Connect(function()
        if not isNoClipping or not char or not char.Parent then
            return
        end
        noclip()
    end)
    
    table.insert(noClipConnections, noClipLoop)
    
    
    local function setupNoClipForPart(part)
        if part:IsA("BasePart") and part.CanCollide then
            part.CanCollide = false
        end
    end
    
    local descendantAdded = char.DescendantAdded:Connect(setupNoClipForPart)
    table.insert(noClipConnections, descendantAdded)
    
    
    task.spawn(function()
        task.wait(0.5)
        if isNoClipping and char and char.Parent then
            noclip()
        end
    end)
end

local function stopNoClip()
    isNoClipping = false
    
    local char = Players.LocalPlayer.Character
    if not char then return end
    
    
    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
    
    
    for _, connection in ipairs(noClipConnections) do
        if connection then
            if typeof(connection) == "RBXScriptConnection" then
                pcall(function() connection:Disconnect() end)
            elseif typeof(connection) == "Instance" then
                pcall(function() connection:Destroy() end)
            end
        end
    end
    noClipConnections = {}
end

local function startSpeedHack()
    local char = Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    
    isSpeedHacking = true
    originalWalkSpeed = hum.WalkSpeed
    originalJumpPower = hum.JumpPower
    
    hum.WalkSpeed = SpeedHackConfig.Speed * 16
    
    if SpeedHackConfig.UseJumpPower then
        hum.JumpPower = SpeedHackConfig.Speed * 50
    end
    
    local function onCharacterAdded(newChar)
        local newHum = newChar:WaitForChild("Humanoid")
        if isSpeedHacking then
            newHum.WalkSpeed = SpeedHackConfig.Speed * 16
            if SpeedHackConfig.UseJumpPower then
                newHum.JumpPower = SpeedHackConfig.Speed * 50
            end
        end
    end
    
    local characterAddedConnection = Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
    table.insert(speedHackConnections, characterAddedConnection)
    
    local speedLoop = RunService.Heartbeat:Connect(function()
        if not isSpeedHacking then return end
        
        local currentChar = Players.LocalPlayer.Character
        local currentHum = currentChar and currentChar:FindFirstChildOfClass("Humanoid")
        
        if currentHum then
            if currentHum.WalkSpeed ~= SpeedHackConfig.Speed * 16 then
                currentHum.WalkSpeed = SpeedHackConfig.Speed * 16
            end
            
            if SpeedHackConfig.UseJumpPower and currentHum.JumpPower ~= SpeedHackConfig.Speed * 50 then
                currentHum.JumpPower = SpeedHackConfig.Speed * 50
            end
        end
    end)
    
    table.insert(speedHackConnections, speedLoop)
end

local function stopSpeedHack()
    isSpeedHacking = false
    
    local char = Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.WalkSpeed = originalWalkSpeed
        hum.JumpPower = originalJumpPower
    end
    
    for _, connection in ipairs(speedHackConnections) do
        if connection then
            if typeof(connection) == "RBXScriptConnection" then
                pcall(function() connection:Disconnect() end)
            elseif typeof(connection) == "Instance" then
                pcall(function() connection:Destroy() end)
            end
        end
    end
    speedHackConnections = {}
end


local function startLongJump()
    local char = Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    
    isLongJumping = true
    originalLongJumpPower = hum.JumpPower
    
    hum.JumpPower = LongJumpConfig.JumpPower
    
    
    local function onCharacterAdded(newChar)
        local newHum = newChar:WaitForChild("Humanoid")
        if isLongJumping then
            newHum.JumpPower = LongJumpConfig.JumpPower
        end
    end
    
    local characterAddedConnection = Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
    table.insert(longJumpConnections, characterAddedConnection)
    
    
    local longJumpLoop = RunService.Heartbeat:Connect(function()
        if not isLongJumping then return end
        
        local currentChar = Players.LocalPlayer.Character
        local currentHum = currentChar and currentChar:FindFirstChildOfClass("Humanoid")
        
        if currentHum and currentHum.JumpPower ~= LongJumpConfig.JumpPower then
            currentHum.JumpPower = LongJumpConfig.JumpPower
        end
    end)
    
    table.insert(longJumpConnections, longJumpLoop)
end

local function stopLongJump()
    isLongJumping = false
    
    local char = Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.JumpPower = originalLongJumpPower
    end
    
    
    for _, connection in ipairs(longJumpConnections) do
        if connection then
            if typeof(connection) == "RBXScriptConnection" then
                pcall(function() connection:Disconnect() end)
            elseif typeof(connection) == "Instance" then
                pcall(function() connection:Destroy() end)
            end
        end
    end
    longJumpConnections = {}
end


local function startInfiniteJump()
    local char = Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not hum or not root then return end
    
    isInfiniteJumping = true
    lastJumpTime = 0
    
    
    local function onJumpRequest()
        if not isInfiniteJumping then return end
        
        local currentTime = tick()
        if currentTime - lastJumpTime < 0.1 then return end 
        
        lastJumpTime = currentTime
        
        
        local bv = Instance.new("BodyVelocity", root)
        bv.MaxForce = Vector3.new(0, math.huge, 0)
        bv.Velocity = Vector3.new(0, InfiniteJumpConfig.JumpPower, 0)
        
        
        task.spawn(function()
            task.wait(0.3)
            if bv and bv.Parent then
                bv:Destroy()
            end
        end)
    end
    
    
    local jumpConnection = hum.Jumping:Connect(onJumpRequest)
    table.insert(infiniteJumpConnections, jumpConnection)
    
    
    local function onInputBegan(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.Space then
            onJumpRequest()
        end
    end
    
    local inputConnection = UserInputService.InputBegan:Connect(onInputBegan)
    table.insert(infiniteJumpConnections, inputConnection)
    
    
    local function onCharacterAdded(newChar)
        if isInfiniteJumping then
            task.wait(1) 
            startInfiniteJump() 
        end
    end
    
    local characterAddedConnection = Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
    table.insert(infiniteJumpConnections, characterAddedConnection)
end

local function stopInfiniteJump()
    isInfiniteJumping = false
    lastJumpTime = 0
    
    
    for _, connection in ipairs(infiniteJumpConnections) do
        if connection then
            if typeof(connection) == "RBXScriptConnection" then
                pcall(function() connection:Disconnect() end)
            elseif typeof(connection) == "Instance" then
                pcall(function() connection:Destroy() end)
            end
        end
    end
    infiniteJumpConnections = {}
    
    
    local char = Players.LocalPlayer.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if root then
        for _, child in pairs(root:GetChildren()) do
            if child:IsA("BodyVelocity") then
                child:Destroy()
            end
        end
    end
end


local function createStealthTeleport()
    if not TeleportConfig.TargetPlayer then 
        return 
    end
    
    local char = Players.LocalPlayer.Character
    local targetChar = TeleportConfig.TargetPlayer.Character
    if not char or not targetChar then 
        return 
    end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChild("Humanoid")
    if not root or not targetRoot or not humanoid then 
        return 
    end
    
    isTeleporting = true
    speedResetTimer = 0
    lastSpeedCheck = tick()
    
    
    if not TeleportConfig.OriginalPosition then
        TeleportConfig.OriginalPosition = root.Position
    end
    
    
    if not isNoClipping then
        startNoClip()
    end
    
    
    task.spawn(function()
        task.wait(0.1) 
        if not isNoClipping then
            startNoClip()
        end
        
        
        local char = Players.LocalPlayer.Character
        if char then
            for _, part in pairs(char:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end
    end)
    
    local stealthTeleportLoop = RunService.Heartbeat:Connect(function()
        if not isTeleporting or not targetChar or not targetChar.Parent then
            return
        end
        
        
        if isNoClipping and char and char.Parent then
            for _, part in pairs(char:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end
        
        
        local currentTime = tick()
        speedResetTimer = speedResetTimer + (currentTime - lastSpeedCheck)
        lastSpeedCheck = currentTime
        
        -- Улучшенный сброс скорости (только если не близко к цели)
        if speedResetTimer >= TeleportConfig.MaxSpeedResetTime then
            speedResetTimer = 0
            
            local bv = root:FindFirstChild("BodyVelocity")
            if bv and bv.Velocity.Magnitude > TeleportConfig.SpeedResetThreshold and distance > 5 then
                bv.Velocity = bv.Velocity * 0.8
            end

            if humanoid and humanoid.WalkSpeed > 16 and distance > 5 then
                humanoid.WalkSpeed = math.max(humanoid.WalkSpeed - 1, 16)
            end
        end
        
        local currentTargetRoot = targetChar:FindFirstChild("HumanoidRootPart")
        if currentTargetRoot then
            local targetPos = currentTargetRoot.Position
            local currentPos = root.Position
            local distance = (targetPos - currentPos).Magnitude

                    -- Более частое обновление для движущихся целей
        if lastTeleportPosition then
            local targetMovement = (targetPos - lastTeleportPosition).Magnitude
            if targetMovement > 3 then
                task.wait(0.02) -- Уменьшаем задержку для быстрых целей
            end
        end
        lastTeleportPosition = targetPos
            
            -- Улучшенная логика позиционирования за спиной
            local targetCFrame = currentTargetRoot.CFrame
            local behindPosition = targetCFrame * CFrame.new(0, 0, TeleportConfig.BehindPlayerDistance)
            local behindDistance = (behindPosition.Position - currentPos).Magnitude
            
            local bv = root:FindFirstChild("BodyVelocity")
            if not bv then
                bv = Instance.new("BodyVelocity", root)
                bv.MaxForce = Vector3.new(1e6, 1e6, 1e6)
                bv.Velocity = Vector3.new(0, 0, 0)
            end
            
            -- BodyGyro для стабильного поворота
            local bg = root:FindFirstChild("BodyGyro")
            if not bg then
                bg = Instance.new("BodyGyro", root)
                bg.MaxTorque = Vector3.new(1e6, 1e6, 1e6)
                bg.D = 50
                bg.P = 1000
            end
            
            -- Поворот персонажа в ту же сторону, что и цель
            local targetLookVector = targetCFrame.LookVector
            bg.CFrame = CFrame.lookAt(root.Position, root.Position + targetLookVector)
            
            -- Улучшенная логика следования за движущейся целью
            local targetVelocity = currentTargetRoot.Velocity
            local targetSpeed = targetVelocity.Magnitude
            
            -- Предсказание позиции цели с учетом её скорости
            local predictionTime = 0.1 -- Время предсказания
            local predictedPosition = behindPosition.Position + (targetVelocity * predictionTime)
            local predictedDistance = (predictedPosition - currentPos).Magnitude
            
            -- Адаптивная скорость в зависимости от скорости цели
            local adaptiveSpeed = TeleportConfig.TeleportSpeed
            if targetSpeed > 80 then
                adaptiveSpeed = TeleportConfig.TeleportSpeed * 2.0 -- Максимальная скорость для очень быстрых целей
            elseif targetSpeed > 50 then
                adaptiveSpeed = TeleportConfig.TeleportSpeed * 1.5 -- Увеличиваем скорость для быстрых целей
            elseif targetSpeed > 20 then
                adaptiveSpeed = TeleportConfig.TeleportSpeed * 1.2
            end
            
            if predictedDistance > 1.5 then
                -- Быстрое движение к предсказанной позиции
                local direction = (predictedPosition - currentPos).Unit
                local currentVelocity = bv.Velocity
                local targetVelocity = direction * adaptiveSpeed
                
                -- Более агрессивное ускорение для быстрых целей
                local accelerationFactor = 0.15
                if targetSpeed > 80 then
                    accelerationFactor = 0.5 -- Максимальное ускорение для очень быстрых целей
                elseif targetSpeed > 50 then
                    accelerationFactor = 0.4
                elseif targetSpeed > 30 then
                    accelerationFactor = 0.3
                end
                local velocityDiff = targetVelocity - currentVelocity
                local acceleration = velocityDiff * accelerationFactor
                
                bv.Velocity = currentVelocity + acceleration
            else
                -- Точное следование за целью
                local direction = (predictedPosition - currentPos).Unit
                local correctionSpeed = math.min(predictedDistance * 15, 30)
                
                -- Увеличиваем скорость коррекции для движущихся целей
                if targetSpeed > 10 then
                    correctionSpeed = correctionSpeed * 1.5
                end
                
                bv.Velocity = direction * correctionSpeed
                
                -- Останавливаемся только если очень близко и цель не движется быстро
                if predictedDistance < 0.3 and targetSpeed < 5 then
                    bv.Velocity = Vector3.new(0, 0, 0)
                end
            end
        end
    end)
    
    table.insert(teleportConnections, stealthTeleportLoop)
end

local function startTeleport()
    if not TeleportConfig.TargetPlayer then 
        return 
    end
    
    local char = Players.LocalPlayer.Character
    local targetChar = TeleportConfig.TargetPlayer.Character
    if not char or not targetChar then 
        return 
    end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
    if not root or not targetRoot then 
        return 
    end
    
    isTeleporting = true
    lastTeleportPosition = nil
    speedResetTimer = 0
    lastSpeedCheck = tick()
    
    
    TeleportConfig.OriginalPosition = root.Position
    
    
    if not isNoClipping then
        startNoClip()
    end
    
    
    task.spawn(function()
        task.wait(0.1) 
        if not isNoClipping then
            startNoClip()
        end
        
        
        local char = Players.LocalPlayer.Character
        if char then
            for _, part in pairs(char:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end
    end)
    
    if startTeleportBtn then
        startTeleportBtn.Text = "TELEPORT ACTIVE"
        startTeleportBtn.BackgroundColor3 = Color3.fromRGB(150,0,0)
    end
    if stopTeleportBtn then
        stopTeleportBtn.Text = "STOP TELEPORT"
        stopTeleportBtn.BackgroundColor3 = Color3.fromRGB(0,150,0)
    end
    
    createStealthTeleport()
    
    
    task.spawn(function()
        task.wait(0.2)
        if not isNoClipping then
            startNoClip()
        end
        
        
        local char = Players.LocalPlayer.Character
        if char then
            for _, part in pairs(char:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function stopTeleport()
    isTeleporting = false
    lastTeleportPosition = nil
    speedResetTimer = 0
    TeleportConfig.Enabled = false
    
    local char = Players.LocalPlayer.Character
    if not char then 
        return 
    end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChild("Humanoid")
    
    
    for _, connection in ipairs(teleportConnections) do
        if connection then
            if typeof(connection) == "RBXScriptConnection" then
                pcall(function() connection:Disconnect() end)
            end
        end
    end
    teleportConnections = {}
    
    
    local bv = root and root:FindFirstChild("BodyVelocity")
    if bv then
        
        bv.Velocity = Vector3.new(0, 0, 0)
        task.wait(0.1) 
        bv:Destroy()
    end
    
    local bg = root and root:FindFirstChild("BodyGyro")
    if bg then
        bg:Destroy()
    end
    
    
    if humanoid then
        humanoid.WalkSpeed = 16
        humanoid.JumpPower = 50
    end
    
    
    if root and TeleportConfig.OriginalPosition then
        
        if not isNoClipping then
            startNoClip()
        end
        
        
        local returnConnections = {}
        
        local returnLoop = RunService.Heartbeat:Connect(function()
            if not root or not root.Parent then
                return
            end
            
            local currentPos = root.Position
            local returnPos = TeleportConfig.OriginalPosition
            local distance = (returnPos - currentPos).Magnitude
            
            if distance > 3 then
                local returnBv = root:FindFirstChild("BodyVelocity")
                if not returnBv then
                    returnBv = Instance.new("BodyVelocity", root)
                    returnBv.MaxForce = Vector3.new(1e6, 1e6, 1e6) 
                end
                
                local returnDirection = (returnPos - currentPos).Unit
                local returnSpeed = TeleportConfig.ReturnSpeed
                
                returnSpeed = returnSpeed + math.random(-5, 5)
                
                returnBv.Velocity = returnDirection * returnSpeed
            else
                
                local returnBv = root:FindFirstChild("BodyVelocity")
                if returnBv then
                    returnBv.Velocity = Vector3.new(0, 0, 0)
                    task.wait(0.5) 
                    returnBv:Destroy()
                end
                
                local returnBg = root:FindFirstChild("BodyGyro")
                if returnBg then
                    returnBg:Destroy()
                end
                
                
                root.CFrame = CFrame.new(TeleportConfig.OriginalPosition)
                TeleportConfig.OriginalPosition = nil
                
                
                local freezeBv = Instance.new("BodyVelocity", root)
                freezeBv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
                freezeBv.Velocity = Vector3.new(0, 0, 0)
                
                task.wait(2) 
                
                if freezeBv then
                    freezeBv:Destroy()
                end
                
                
                task.spawn(function()
                    task.wait(5)
                    if isNoClipping then
                        stopNoClip()
                    end
                end)
                
                
                for _, connection in ipairs(returnConnections) do
                    if connection then
                        pcall(function() connection:Disconnect() end)
                    end
                end
                
                if returnLoop then
                    returnLoop:Disconnect()
                end
            end
        end)
        
        table.insert(returnConnections, returnLoop)
    end
    
    
    local humanoid = char and char:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = 16
        humanoid.JumpPower = 50
    end
    
    if startTeleportBtn then
        startTeleportBtn.Text = "START TELEPORT"
        startTeleportBtn.BackgroundColor3 = Color3.fromRGB(0,150,0)
    end
    if stopTeleportBtn then
        stopTeleportBtn.Text = "STOP TELEPORT"
        stopTeleportBtn.BackgroundColor3 = Color3.fromRGB(150,0,0)
    end
end

local function findStands()
    local stands = {}
    local player = Players.LocalPlayer
    local playerChar = player.Character
    local playerRoot = playerChar and playerChar:FindFirstChild("HumanoidRootPart")
    
    if not playerRoot then 
        return stands 
    end
    
    local standNames = {
        "Stand", "StandModel", "StandPart", "StandRoot", "StandHumanoidRootPart",
        "Star Platinum", "The World", "Hierophant Green", "Magician's Red",
        "Hermit Purple", "Silver Chariot", "Tower of Gray", "Dark Blue Moon",
        "Strength", "Wheel of Fortune", "Hanged Man", "Emperor", "Empress",
        "Judgment", "High Priestess", "Death Thirteen", "Lovers", "Sun",
        "Bastet", "Thunder McQueen", "Anubis", "Khnum", "Tohth", "Horus",
        "Atum", "Osiris", "Horus", "Anubis", "Bastet", "Khnum", "Tohth"
    }
    
    local foundCount = 0
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("Model") then
            local isStand = false
            for _, standName in ipairs(standNames) do
                if obj.Name:find(standName) or obj.Name:lower():find(standName:lower()) then
                    isStand = true
                    break
                end
            end
            
            if isStand then
                local standRoot = obj:FindFirstChild("HumanoidRootPart") or obj:FindFirstChild("StandRoot") or obj:FindFirstChild("RootPart")
                if standRoot then
                    local distance = (standRoot.Position - playerRoot.Position).Magnitude
                    if distance <= YBAConfig.StandRange then
                        foundCount = foundCount + 1
                        table.insert(stands, {
                            Model = obj,
                            Root = standRoot,
                            Distance = distance,
                            Name = obj.Name
                        })
                    end
                end
            end
        end
    end
    
    if #stands == 0 then
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("Model") and obj:FindFirstChild("Humanoid") then
                local standRoot = obj:FindFirstChild("HumanoidRootPart")
                if standRoot then
                    local distance = (standRoot.Position - playerRoot.Position).Magnitude
                    if distance <= YBAConfig.StandRange then
                        table.insert(stands, {
                            Model = obj,
                            Root = standRoot,
                            Distance = distance,
                            Name = obj.Name
                        })
                    end
                end
            end
        end
    end
    
    table.sort(stands, function(a, b) return a.Distance < b.Distance end)
    return stands
end

local function freezePlayer()
    local player = Players.LocalPlayer
    local char = player.Character
    if not char then return end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChild("Humanoid")
    
    if root then
        originalPlayerPosition = root.Position
        originalPlayerCFrame = root.CFrame
        
        -- Создаем BodyVelocity для заморозки
        local bv = root:FindFirstChild("BodyVelocity")
        if not bv then
            bv = Instance.new("BodyVelocity", root)
            bv.MaxForce = Vector3.new(1e6, 1e6, 1e6)
        end
        bv.Velocity = Vector3.new(0, 0, 0)
        
        -- Дополнительно отключаем все движения персонажа
        local gyro = root:FindFirstChild("BodyGyro")
        if not gyro then
            gyro = Instance.new("BodyGyro", root)
            gyro.MaxTorque = Vector3.new(1e6, 1e6, 1e6)
        end
        gyro.CFrame = root.CFrame
        
        -- Принудительно отключаем камеру от персонажа
        local camera = workspace.CurrentCamera
        if camera then
            camera.CameraType = Enum.CameraType.Scriptable
        end
    end
    
    if humanoid then
        originalYBAWalkSpeed = humanoid.WalkSpeed
        originalYBAJumpPower = humanoid.JumpPower
        humanoid.WalkSpeed = 0
        humanoid.JumpPower = 0
        
        -- Отключаем все действия персонажа
        humanoid.AutoRotate = false
        humanoid.AutoJumpEnabled = false
    end
end

local function unfreezePlayer()
    local player = Players.LocalPlayer
    local char = player.Character
    if not char then return end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChild("Humanoid")
    
    if root then
        local bv = root:FindFirstChild("BodyVelocity")
        if bv then
            bv:Destroy()
        end
        
        local gyro = root:FindFirstChild("BodyGyro")
        if gyro then
            gyro:Destroy()
        end
    end
    
    if humanoid then
        humanoid.WalkSpeed = originalYBAWalkSpeed
        humanoid.JumpPower = originalYBAJumpPower
        
        -- Восстанавливаем стандартные настройки персонажа
        humanoid.AutoRotate = true
        humanoid.AutoJumpEnabled = true
    end
end

local function activateFreeCamera(stand)
    if not stand or not stand.Root then 
        print("YBA: Ошибка - стенд или его Root не найден")
        return false
    end
    
    print("YBA: Активируем управление стендом: " .. stand.Name)

    if YBAConfig.FreezePlayer then
        print("YBA: Замораживаем игрока...")
        freezePlayer()
    end

    freeCameraActive = true
    freeCameraTarget = stand

    if YBAFreeCamera.Start(stand) then
        print("YBA: Управление стендом активировано от третьего лица")
        return true
    else
        print("YBA: Не удалось активировать управление стендом")
        return false
    end
end

local function disableFreeCamera()
    if not freeCameraActive then return end
    
    print("YBA: Отключаем управление стендом")
    
    freeCameraActive = false
    freeCameraTarget = nil

    YBAFreeCamera.Stop()

    local player = Players.LocalPlayer
    if player and player.Character then
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.AutoRotate = true
        end
    end

    for _, connection in ipairs(freeCameraConnections) do
        if connection then
            pcall(function() connection:Disconnect() end)
        end
    end
    freeCameraConnections = {}
    
    print("YBA: Управление стендом отключено")

    local player = Players.LocalPlayer
    if player and player.Character then
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = originalYBAWalkSpeed
            humanoid.JumpPower = originalYBAJumpPower
        end

        local root = player.Character:FindFirstChild("HumanoidRootPart")
        if root then
            local bv = root:FindFirstChild("BodyVelocity")
            if bv then
                bv:Destroy()
            end
            
            local gyro = root:FindFirstChild("BodyGyro")
            if gyro then
                gyro:Destroy()
            end
        end
    end
end

local function controlStand(stand)
    if not stand or not stand.Root then 
        print("YBA: Ошибка - стенд или его Root не найден")
        return 
    end
    
    print("YBA: Начинаем управление стендом: " .. stand.Name)
    controlledStand = stand

    if activateFreeCamera(stand) then
        print("YBA: Свободная камера активирована для стенда: " .. stand.Name)
    else
        print("YBA: Не удалось активировать свободную камеру для стенда: " .. stand.Name)
    end
end

local function startYBA()
    if isYBAEnabled then return end
    
    isYBAEnabled = true
    YBAConfig.Enabled = true
    
    local stands = findStands()
    
    if #stands == 0 then
        return
    end
    
    local targetStand = stands[1]
    
    if YBAConfig.FreezePlayer then
        freezePlayer()
    end
    
    if YBAConfig.SwitchCamera then
    end
    
    if YBAConfig.TransferControl then
        activateFreeCamera(targetStand)
    end
    
    -- Добавляем обработчик атак стенда
    local standAttackHandler = UserInputService.InputBegan:Connect(function(input, gp)
        if not gp and isYBAEnabled and controlledStand and controlledStand.Root then
            local attackKey = nil
            local attackType = nil
            
            -- Определяем клавишу атаки
            if input.KeyCode == Enum.KeyCode.F then
                attackKey = "F"
                attackType = "LightAttack"
            elseif input.KeyCode == Enum.KeyCode.E then
                attackKey = "E"
                attackType = "HeavyAttack"
            elseif input.KeyCode == Enum.KeyCode.R then
                attackKey = "R"
                attackType = "SpecialAttack"
            elseif input.KeyCode == Enum.KeyCode.T then
                attackKey = "T"
                attackType = "UltimateAttack"
            elseif input.KeyCode == Enum.KeyCode.Y then
                attackKey = "Y"
                attackType = "BarrageAttack"
            elseif input.KeyCode == Enum.KeyCode.Q then
                attackKey = "Q"
                attackType = "StandAbility"
            end
            
            if attackKey and attackType then
                print("YBA: Атака стенда - Клавиша:", attackKey, "Тип:", attackType)
                
                -- Отправляем атаку от имени стенда
                local standRoot = controlledStand.Root
                local standPosition = standRoot.Position
                
                -- Создаем RemoteEvent для отправки атаки от имени стенда
                local attackEvent = game:GetService("ReplicatedStorage"):FindFirstChild("StandAttackEvent")
                if not attackEvent then
                    attackEvent = Instance.new("RemoteEvent")
                    attackEvent.Name = "StandAttackEvent"
                    attackEvent.Parent = game:GetService("ReplicatedStorage")
                end
                
                -- Отправляем данные атаки
                local attackData = {
                    AttackType = attackType,
                    StandPosition = standPosition,
                    StandName = controlledStand.Name,
                    PlayerPosition = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and Players.LocalPlayer.Character.HumanoidRootPart.Position or Vector3.new(0,0,0),
                    Timestamp = tick()
                }
                
                attackEvent:FireServer(attackData)
                print("YBA: Атака отправлена от имени стенда:", controlledStand.Name)
            end
        end
    end)
    
    table.insert(standControlConnections, standAttackHandler)
    
    -- Добавляем постоянный мониторинг атак для стенда
    local standAttackMonitor = RunService.Heartbeat:Connect(function()
        if isYBAEnabled and controlledStand and controlledStand.Root then
            local isAttacking = false
            local attackType = nil
            
            -- Проверяем нажатие клавиш атаки
            if UserInputService:IsKeyDown(Enum.KeyCode.F) then
                isAttacking = true
                attackType = "LightAttack"
            elseif UserInputService:IsKeyDown(Enum.KeyCode.E) then
                isAttacking = true
                attackType = "HeavyAttack"
            elseif UserInputService:IsKeyDown(Enum.KeyCode.R) then
                isAttacking = true
                attackType = "SpecialAttack"
            elseif UserInputService:IsKeyDown(Enum.KeyCode.T) then
                isAttacking = true
                attackType = "UltimateAttack"
            elseif UserInputService:IsKeyDown(Enum.KeyCode.Y) then
                isAttacking = true
                attackType = "BarrageAttack"
            elseif UserInputService:IsKeyDown(Enum.KeyCode.Q) then
                isAttacking = true
                attackType = "StandAbility"
            end
            
            if isAttacking and attackType then
                -- Отправляем атаку от имени стенда
                local standRoot = controlledStand.Root
                local standPosition = standRoot.Position
                
                -- Создаем RemoteEvent для отправки атаки от имени стенда
                local attackEvent = game:GetService("ReplicatedStorage"):FindFirstChild("StandAttackEvent")
                if not attackEvent then
                    attackEvent = Instance.new("RemoteEvent")
                    attackEvent.Name = "StandAttackEvent"
                    attackEvent.Parent = game:GetService("ReplicatedStorage")
                end
                
                -- Отправляем данные атаки
                local attackData = {
                    AttackType = attackType,
                    StandPosition = standPosition,
                    StandName = controlledStand.Name,
                    PlayerPosition = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and Players.LocalPlayer.Character.HumanoidRootPart.Position or Vector3.new(0,0,0),
                    Timestamp = tick(),
                    FromStand = true -- Указываем что атака идет от стенда
                }
                
                attackEvent:FireServer(attackData)
            end
        end
    end)
    
    table.insert(standControlConnections, standAttackMonitor)
    
    -- Добавляем перехватчик всех RemoteEvents для перенаправления атак через стенд
    local originalFireServer = nil
    local originalInvokeServer = nil
    
    -- Перехватываем FireServer для всех RemoteEvents
    local mt = getrawmetatable(game)
    local oldNamecall = mt.__namecall
    setreadonly(mt, false)
    
    mt.__namecall = newcclosure(function(self, ...)
        local args = {...}
        local method = getnamecallmethod()
        
        if method == "FireServer" and isYBAEnabled and controlledStand and controlledStand.Root then
            -- Если это атака или способность, перенаправляем через стенд
            local eventName = self.Name
            if eventName and (eventName:find("Attack") or eventName:find("Ability") or eventName:find("Stand") or eventName:find("Combat")) then
                print("YBA: Перехвачена атака:", eventName)
                
                -- Модифицируем данные атаки для отправки от имени стенда
                local standRoot = controlledStand.Root
                local standPosition = standRoot.Position
                local playerRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                local playerPosition = playerRoot and playerRoot.Position or Vector3.new(0,0,0)
                
                -- Вычисляем расстояние между стендом и игроком
                local distance = (standPosition - playerPosition).Magnitude
                
                -- Если стенд находится дальше 50 метров, обманываем сервер
                if distance > 50 then
                    print("YBA: Стенд находится на расстоянии", math.floor(distance), "м. Обманываем сервер...")
                    
                    -- Временно перемещаем стенд ближе к игроку для атаки
                    local originalStandPosition = standRoot.Position
                    local fakePosition = playerPosition + (standPosition - playerPosition).Unit * 45 -- 45 метров от игрока
                    
                    -- Перемещаем стенд на фальшивую позицию
                    standRoot.CFrame = CFrame.new(fakePosition)
                    
                    -- Отправляем атаку с фальшивой позиции
                    if args[1] and type(args[1]) == "table" then
                        args[1].StandPosition = fakePosition
                        args[1].FromStand = true
                        args[1].StandName = controlledStand.Name
                        args[1].FakePosition = true
                    elseif args[1] then
                        local originalData = args[1]
                        args[1] = {
                            OriginalData = originalData,
                            StandPosition = fakePosition,
                            FromStand = true,
                            StandName = controlledStand.Name,
                            FakePosition = true
                        }
                    end
                    
                    -- Возвращаем стенд на оригинальную позицию после небольшой задержки
                    spawn(function()
                        task.wait(0.1)
                        if standRoot and standRoot.Parent then
                            standRoot.CFrame = CFrame.new(originalStandPosition)
                        end
                    end)
                    
                    print("YBA: Атака отправлена с фальшивой позиции для обхода ограничения")
                else
                    -- Если стенд в пределах 50 метров, отправляем нормально
                    if args[1] and type(args[1]) == "table" then
                        args[1].StandPosition = standPosition
                        args[1].FromStand = true
                        args[1].StandName = controlledStand.Name
                    elseif args[1] then
                        local originalData = args[1]
                        args[1] = {
                            OriginalData = originalData,
                            StandPosition = standPosition,
                            FromStand = true,
                            StandName = controlledStand.Name
                        }
                    end
                end
                
                print("YBA: Атака перенаправлена через стенд:", controlledStand.Name)
            end
        end
        
        return oldNamecall(self, ...)
    end)
    
    setreadonly(mt, true)
    
    print("YBA: Перехватчик RemoteEvents с обходом ограничений активирован")
    
    -- Создаем систему призрачного стенда для атак на больших расстояниях
    local ghostStand = nil
    
    local function createGhostStand()
        if ghostStand then
            ghostStand:Destroy()
        end
        
        -- Создаем призрачный стенд для атак
        ghostStand = Instance.new("Part")
        ghostStand.Name = "GhostStand"
        ghostStand.Anchored = true
        ghostStand.CanCollide = false
        ghostStand.Transparency = 1 -- Полностью прозрачный
        ghostStand.Size = Vector3.new(1, 1, 1)
        ghostStand.Parent = workspace
        
        print("YBA: Призрачный стенд создан для атак на больших расстояниях")
        return ghostStand
    end
    
    -- Функция для атаки через призрачный стенд
    local function attackThroughGhostStand(attackType, targetPosition)
        if not ghostStand then
            ghostStand = createGhostStand()
        end
        
        local playerRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local playerPosition = playerRoot and playerRoot.Position or Vector3.new(0,0,0)
        
        -- Размещаем призрачный стенд в пределах 50 метров от игрока, но направляем атаку на цель
        local direction = (targetPosition - playerPosition).Unit
        local ghostPosition = playerPosition + direction * 45 -- 45 метров от игрока
        
        ghostStand.Position = ghostPosition
        
        -- Создаем RemoteEvent для атаки через призрачный стенд
        local ghostAttackEvent = game:GetService("ReplicatedStorage"):FindFirstChild("GhostStandAttack")
        if not ghostAttackEvent then
            ghostAttackEvent = Instance.new("RemoteEvent")
            ghostAttackEvent.Name = "GhostStandAttack"
            ghostAttackEvent.Parent = game:GetService("ReplicatedStorage")
        end
        
        -- Отправляем атаку через призрачный стенд
        local attackData = {
            AttackType = attackType,
            StandPosition = ghostPosition,
            TargetPosition = targetPosition,
            StandName = "GhostStand",
            FromGhostStand = true,
            OriginalStandName = controlledStand.Name,
            Timestamp = tick()
        }
        
        ghostAttackEvent:FireServer(attackData)
        print("YBA: Атака отправлена через призрачный стенд на цель:", targetPosition)
    end
    
    -- Добавляем обработчик для атак через призрачный стенд
    local ghostAttackHandler = UserInputService.InputBegan:Connect(function(input, gp)
        if not gp and isYBAEnabled and controlledStand and controlledStand.Root then
            local attackType = nil
            local keyPressed = input.KeyCode.Name
            
            if keyPressed == "F" then attackType = "LightAttack"
            elseif keyPressed == "E" then attackType = "HeavyAttack"
            elseif keyPressed == "R" then attackType = "SpecialAttack"
            elseif keyPressed == "T" then attackType = "UltimateAttack"
            elseif keyPressed == "Y" then attackType = "BarrageAttack"
            elseif keyPressed == "Q" then attackType = "StandAbility"
            end
            
            if attackType then
                local standRoot = controlledStand.Root
                local standPosition = standRoot.Position
                local playerRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                local playerPosition = playerRoot and playerRoot.Position or Vector3.new(0,0,0)
                
                local distance = (standPosition - playerPosition).Magnitude
                
                if distance > 50 then
                    print("YBA: Используем призрачный стенд для атаки на расстоянии", math.floor(distance), "м")
                    attackThroughGhostStand(attackType, standPosition)
                end
            end
        end
    end)
    
    table.insert(standControlConnections, ghostAttackHandler)
end

local function stopYBA()
    if not isYBAEnabled then return end
    
    isYBAEnabled = false
    YBAConfig.Enabled = false
    
    disableFreeCamera()
    unfreezePlayer()
    
    for _, connection in ipairs(standControlConnections) do
        if connection then
            pcall(function() connection:Disconnect() end)
        end
    end
    standControlConnections = {}
    controlledStand = nil
    
    -- Восстанавливаем оригинальный метаметод
    local mt = getrawmetatable(game)
    if mt and mt.__namecall then
        setreadonly(mt, false)
        mt.__namecall = mt.__namecall -- Восстанавливаем оригинальный метод
        setreadonly(mt, true)
        print("YBA: Перехватчик RemoteEvents отключен")
    end
    
    -- Удаляем призрачный стенд
    local ghostStand = workspace:FindFirstChild("GhostStand")
    if ghostStand then
        ghostStand:Destroy()
        print("YBA: Призрачный стенд удален")
    end
end

local function getAlivePlayers()
    local alivePlayers = {}
    
    if not Players then
        return alivePlayers
    end
    
    if not Players.LocalPlayer then
        return alivePlayers
    end
    
    local allPlayers = Players:GetPlayers()
    if not allPlayers then
        return alivePlayers
    end
    
    for i, player in ipairs(allPlayers) do
        if player then
            if player ~= Players.LocalPlayer then
                if player.Character then
                    local humanoid = player.Character:FindFirstChild("Humanoid")
                    if humanoid then
                        if humanoid.Health > 0 then
                            table.insert(alivePlayers, player)
                        end
                    end
                end
            end
        end
    end
    
    return alivePlayers
end


UserInputService.InputBegan:Connect(function(input, gp)
    if not gp then
        if FlyConfig.ToggleKey and input.KeyCode == FlyConfig.ToggleKey then
            FlyConfig.Enabled = not FlyConfig.Enabled
            if FlyConfig.Enabled then 
                startFly() 
            else 
                stopFly() 
            end
            
            if guiCallbacks.fly then
                guiCallbacks.fly.Text = "Fly: " .. (FlyConfig.Enabled and "ON" or "OFF")
            end
        elseif NoClipConfig.ToggleKey and input.KeyCode == NoClipConfig.ToggleKey then
            NoClipConfig.Enabled = not NoClipConfig.Enabled
            if NoClipConfig.Enabled then 
                startNoClip() 
            else 
                stopNoClip() 
            end
            
            if guiCallbacks.noClip then
                guiCallbacks.noClip.Text = "NoClip: " .. (NoClipConfig.Enabled and "ON" or "OFF")
            end
        elseif SpeedHackConfig.ToggleKey and input.KeyCode == SpeedHackConfig.ToggleKey then
            SpeedHackConfig.Enabled = not SpeedHackConfig.Enabled
            if SpeedHackConfig.Enabled then 
                startSpeedHack() 
            else 
                stopSpeedHack() 
            end
            
            if guiCallbacks.speedHack then
                guiCallbacks.speedHack.Text = "SpeedHack: " .. (SpeedHackConfig.Enabled and "ON" or "OFF")
            end
        elseif TeleportConfig.ToggleKey and input.KeyCode == TeleportConfig.ToggleKey then
            if TeleportConfig.Enabled then
                stopTeleport()
                TeleportConfig.Enabled = false
            else
                if TeleportConfig.TargetPlayer then
                    startTeleport()
                    TeleportConfig.Enabled = true
                else
                    print("Сначала выберите игрока для телепортации")
                end
            end
            
            if guiCallbacks.teleport then
                guiCallbacks.teleport.Text = "Выбранный игрок: " .. (TeleportConfig.SelectedPlayerName or "Не выбран")
            end
        elseif LongJumpConfig.ToggleKey and input.KeyCode == LongJumpConfig.ToggleKey then
            LongJumpConfig.Enabled = not LongJumpConfig.Enabled
            if LongJumpConfig.Enabled then 
                startLongJump() 
            else 
                stopLongJump() 
            end
            
            if guiCallbacks.longJump then
                guiCallbacks.longJump.Text = "Long Jump: " .. (LongJumpConfig.Enabled and "ON" or "OFF")
            end
        elseif InfiniteJumpConfig.ToggleKey and input.KeyCode == InfiniteJumpConfig.ToggleKey then
            InfiniteJumpConfig.Enabled = not InfiniteJumpConfig.Enabled
            if InfiniteJumpConfig.Enabled then 
                startInfiniteJump() 
            else 
                stopInfiniteJump() 
            end
            
            if guiCallbacks.infiniteJump then
                guiCallbacks.infiniteJump.Text = "Infinite Jump: " .. (InfiniteJumpConfig.Enabled and "ON" or "OFF")
            end
        elseif NoClipConfig.ForceToggleKey and input.KeyCode == NoClipConfig.ForceToggleKey then
            if isNoClipping then
                stopNoClip()
            else
                startNoClip()
            end
        elseif YBAConfig.ToggleKey and input.KeyCode == YBAConfig.ToggleKey then
            if YBAConfig.Enabled then
                stopYBA()
            else
                startYBA()
            end
            
            if guiCallbacks.yba then
                guiCallbacks.yba.Text = "YBA Stand Range: " .. (YBAConfig.Enabled and "ON" or "OFF")
            end
        elseif AntiTimeStopConfig.ToggleKey and input.KeyCode == AntiTimeStopConfig.ToggleKey then
            -- Временная активация Anti Time Stop (как кнопка)
            if not isAntiTimeStopEnabled then
                -- Включаем Anti Time Stop
                AntiTimeStopConfig.Enabled = true
                startAntiTimeStop()
                
                if guiCallbacks.antiTimeStop then
                    guiCallbacks.antiTimeStop.Text = "Anti Time Stop: ACTIVATING..."
                end
                
                -- Асинхронно ждем 0.5 секунды и выключаем
                spawn(function()
                    task.wait(0.5)
                    
                    -- Выключаем Anti Time Stop
                    AntiTimeStopConfig.Enabled = false
                    stopAntiTimeStop()
                    
                    if guiCallbacks.antiTimeStop then
                        guiCallbacks.antiTimeStop.Text = "Anti Time Stop: READY"
                    end
                end)
            else
                -- Если уже активно, показываем сообщение
                if guiCallbacks.antiTimeStop then
                    guiCallbacks.antiTimeStop.Text = "Anti Time Stop: ALREADY ACTIVE"
                    spawn(function()
                        task.wait(1)
                        guiCallbacks.antiTimeStop.Text = "Anti Time Stop: READY"
                    end)
                end
            end
        -- Удален обработчик клавиши I для Item ESP
        end
    end
end)


local ESPs, Lines = {}, {}
local FOVCircle

local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 2
FOVCircle.NumSides = 100
FOVCircle.Filled = false
FOVCircle.Visible = false


local function getName(p)
    return p.Name
end
local function getHealth(p)
    local h = p.Character and p.Character:FindFirstChild("Humanoid")
    return (h and h.Health>0) and math.floor(h.Health) or 0
end
local function isAlive(p) return getHealth(p)>0 end
local function getRainbow() return Color3.fromHSV((tick()%5)/5,1,1) end
local function getESPColor(p)
    if Config.ESP.Rainbow then return getRainbow() end
    if Config.ESP.TeamCheck then return (p.TeamColor==Players.LocalPlayer.TeamColor) and Config.ESP.TeamColor or Config.ESP.EnemyColor end
    return Config.ESP.FillColor
end
local function getOutlineColor(p)
    if Config.ESP.Rainbow then return getRainbow() end
    if Config.ESP.TeamCheck then return (p.TeamColor==Players.LocalPlayer.TeamColor) and Config.ESP.TeamColor or Config.ESP.EnemyColor end
    return Config.ESP.OutlineColor
end
local function rayVisible(p)
    if not Config.Aimbot.VisibilityCheck then return true end
    local cam=workspace.CurrentCamera
    local head=p.Character and p.Character:FindFirstChild("Head") if not head then return false end
    local rp=RaycastParams.new()
    rp.FilterType=Enum.RaycastFilterType.Blacklist
    rp.FilterDescendantsInstances={Players.LocalPlayer.Character,p.Character}
    return not workspace:Raycast(cam.CFrame.Position, head.Position-cam.CFrame.Position, rp)
end


local function createOrUpdateESP(p)
    if not ESPs[p] then
        local hl=Instance.new("Highlight"); hl.Adornee=p.Character; hl.DepthMode=Enum.HighlightDepthMode.AlwaysOnTop; hl.Parent=p.Character
        local bg=Instance.new("BillboardGui",p.Character); bg.AlwaysOnTop=true; bg.Size=UDim2.new(0,200,0,30); bg.StudsOffset=Vector3.new(0,2,0)
        local tl=Instance.new("TextLabel",bg); tl.Size=UDim2.new(1,0,1,0); tl.BackgroundTransparency=1; tl.Font=Config.ESP.Font; tl.TextSize=18
        ESPs[p]={hl=hl,bg=bg,tl=tl}
    end
    local d=ESPs[p]
    d.hl.FillColor=getESPColor(p); d.hl.FillTransparency=Config.ESP.FillTransparency
    d.hl.OutlineColor=getOutlineColor(p); d.hl.OutlineTransparency=Config.ESP.ShowOutline and Config.ESP.OutlineTransparency or 1
    d.tl.TextColor3=Config.ESP.TextColor
    d.tl.Text=string.format("%s | HP:%d | %dm",getName(p),getHealth(p),math.floor((Players.LocalPlayer.Character.HumanoidRootPart.Position-p.Character.HumanoidRootPart.Position).Magnitude))
end

local function removeESP(p)
    if ESPs[p] then 
        if ESPs[p].hl and ESPs[p].hl.Parent then ESPs[p].hl:Destroy() end
        if ESPs[p].bg and ESPs[p].bg.Parent then ESPs[p].bg:Destroy() end
        ESPs[p]=nil 
    end
    if Lines[p] then Lines[p]:Remove(); Lines[p]=nil end
end


local function isPlayerAlive(player)
    if not player then 
        return false 
    end
    
    if not player.Name then
        return false
    end
    
    if not player.Character then 
        return false 
    end
    local humanoid = player.Character:FindFirstChild("Humanoid")
    if not humanoid then 
        return false 
    end
    local isAlive = humanoid.Health > 0
    return isAlive
end

local function isPlayerOnServer(player)
    if not player or not player.Character then return false end
    local humanoid = player.Character:FindFirstChild("Humanoid")
    if not humanoid then return false end
    return humanoid.Health > 0 and humanoid.Parent ~= nil
end


local function onPlayerDied(player)
    removeESP(player)
end

local function onPlayerRespawned(player)
    if Config.ESP.Enabled and player ~= Players.LocalPlayer then
        spawn(function()
            wait(2) 
            if isPlayerAlive(player) then
                createOrUpdateESP(player)
            end
        end)
    end
end


local function setupPlayerESP(player)
    if player == Players.LocalPlayer then return end
    
    
    local function onCharacterAdded(char)
        local humanoid = char:WaitForChild("Humanoid")
        
        
        humanoid.Died:Connect(function()
            onPlayerDied(player)
        end)
        
        
        humanoid.StateChanged:Connect(function(_, new)
            if new == Enum.HumanoidStateType.Dead then
                onPlayerDied(player)
            elseif new == Enum.HumanoidStateType.Running then
                onPlayerRespawned(player)
            end
        end)
        
        
        char.AncestryChanged:Connect(function(_, parent)
            if not parent then
                onPlayerDied(player)
            end
        end)
    end
    
    if player.Character then
        onCharacterAdded(player.Character)
    end
    player.CharacterAdded:Connect(onCharacterAdded)
    player.CharacterRemoving:Connect(function()
        onPlayerDied(player)
    end)
end


for _, player in ipairs(Players:GetPlayers()) do
    setupPlayerESP(player)
end


Players.PlayerAdded:Connect(setupPlayerESP)


Players.PlayerRemoving:Connect(function(player)
    removeESP(player)
end)

local function getClosestTarget()
    local cam = workspace.CurrentCamera
    local closest, minDist = nil, Config.Aimbot.FOV

    for _, p in ipairs(Players:GetPlayers()) do
        if p == Players.LocalPlayer then continue end
        if Config.Aimbot.TeamCheck and p.Team == Players.LocalPlayer.Team then continue end
        if not isAlive(p) then continue end
        if Config.Aimbot.VisibilityCheck and not rayVisible(p) then continue end

        local head = p.Character and p.Character:FindFirstChild("Head")
        if not head then continue end
        local screenPos, onScreen = cam:WorldToViewportPoint(head.Position)
        if not onScreen then continue end

        local dist = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(cam.ViewportSize.X/2, cam.ViewportSize.Y/2)).Magnitude
        if dist < minDist then
            closest = head
            minDist = dist
        end
    end
    return closest
end


RunService.RenderStepped:Connect(function()
    local cam = workspace.CurrentCamera
    for _, player in ipairs(Players:GetPlayers()) do
        if player == Players.LocalPlayer then continue end
        
        local char = player.Character
        local hum = char and char:FindFirstChild("Humanoid")
        local root = char and char:FindFirstChild("HumanoidRootPart")
        
        if isPlayerAlive(player) and root then
            if Config.ESP.Enabled then
                createOrUpdateESP(player)
                if Config.ESP.ShowLines then
                    if not Lines[player] then
                        local ln = Drawing.new("Line")
                        ln.Thickness = 2
                        ln.Transparency = 1
                        Lines[player] = ln
                    end
                    local pos, onScreen = cam:WorldToViewportPoint(root.Position)
                    Lines[player].Visible = onScreen
                    if onScreen then
                        Lines[player].From = Vector2.new(cam.ViewportSize.X/2, cam.ViewportSize.Y)
                        Lines[player].To = Vector2.new(pos.X, pos.Y)
                        Lines[player].Color = getESPColor(player)
                    end
                elseif Lines[player] then
                    Lines[player].Visible = false
                end
            else
                removeESP(player)
            end
        else
            
            removeESP(player)
        end
    end

    
if Config.Aimbot.Enabled then
    local target = getClosestTarget()
    if target then
        local cam = workspace.CurrentCamera
        cam.CFrame = CFrame.lookAt(cam.CFrame.Position, target.Position)
    end
end


local cam = workspace.CurrentCamera
FOVCircle.Visible = Config.Aimbot.Enabled
FOVCircle.Position = Vector2.new(cam.ViewportSize.X/2, cam.ViewportSize.Y/2)
FOVCircle.Color = Config.Aimbot.FOVRainbow and getRainbow() or Config.Aimbot.FOVColor
FOVCircle.Radius = Config.Aimbot.FOV


    
end)


UserInputService.InputBegan:Connect(function(inp, gp)
    if gp then return end
    if inp.UserInputType == Enum.UserInputType.Keyboard then
        if Config.ESP.ToggleKey and inp.KeyCode == Config.ESP.ToggleKey then
            Config.ESP.Enabled = not Config.ESP.Enabled
            print("ESP toggled:", Config.ESP.Enabled)
        elseif Config.Aimbot.ToggleKey and inp.KeyCode == Config.Aimbot.ToggleKey then
            Config.Aimbot.Enabled = not Config.Aimbot.Enabled
            print("Aimbot toggled:", Config.Aimbot.Enabled)
        -- Удален второй обработчик клавиши I для Item ESP
        end
    end
end)


local itemESPEnabled = false
local itemESPConnections = {}
local itemESPElements = {}

local YBA_ITEM_NAMES = {
    -- Основные предметы
    ["Mysterious Arrow"] = true,
    ["Rokakaka"] = true,
    ["Pure Rokakaka"] = true,
    ["Diamond"] = true,
    ["Gold Coin"] = true,
    ["Steel Ball"] = true,
    ["Clackers"] = true,
    ["Caesar's Headband"] = true,
    ["Zeppeli's Hat"] = true,
    ["Zeppeli's Scarf"] = true,
    ["Ancient Scroll"] = true,
    ["Quinton's Glove"] = true,
    ["Stone Mask"] = true,
    ["Lucky Arrow"] = true,
    ["Lucky Stone Mask"] = true,

    ["Rib Cage of The Saint's Corpse"] = true,
    
    ["Ancient Scroll"] = true,
    ["DIO's Diary"] = true,
    ["DIO's Bone"] = true,
    ["DIO's Diary Page"] = true,
    ["Lucky Stone Mask"] = true,
}

local function findYBAItems()
    local items = {}
    local player = Players.LocalPlayer
    local playerChar = player.Character
    local playerRoot = playerChar and playerChar:FindFirstChild("HumanoidRootPart")
    if not playerRoot then 
        return items 
    end

    local foundFolders = {}
    
    local targetFolder = workspace:FindFirstChild("Item_Spawns")
    if targetFolder then
        local itemsFolder = targetFolder:FindFirstChild("Items")
        if itemsFolder then
            table.insert(foundFolders, itemsFolder)
        end
    end
    
    if #foundFolders == 0 then
        local possibleFolders = {
            workspace:FindFirstChild("Items"),
            workspace:FindFirstChild("items"),
            workspace:FindFirstChild("ItemSpawns"),
            workspace:FindFirstChild("itemspawns"),
            workspace:FindFirstChild("ItemSpawn"),
            workspace:FindFirstChild("itemspawn"),
            workspace:FindFirstChild("Spawns"),
            workspace:FindFirstChild("spawns"),
            workspace:FindFirstChild("World"),
            workspace:FindFirstChild("world"),
            workspace:FindFirstChild("Map"),
            workspace:FindFirstChild("map"),
            workspace:FindFirstChild("Game"),
            workspace:FindFirstChild("game")
        }
        
        for _, folder in ipairs(possibleFolders) do
            if folder then
                table.insert(foundFolders, folder)
            end
        end
    end
    
    if #foundFolders == 0 then 
        return items 
    end
    
    local foundCount = 0
    local searchedModels = {}
    local debugCount = 0

    for _, folder in ipairs(foundFolders) do
        local function searchInFolder(currentFolder, depth)
            if depth > 3 then return end
            
            for _, child in ipairs(currentFolder:GetChildren()) do
                debugCount = debugCount + 1
                
                if child:IsA("Model") then
                    if not searchedModels[child] then
                        searchedModels[child] = true
                        
                        local proximityPrompt = child:FindFirstChild("ProximityPrompt")
                        local itemName = child.Name
                        
                        if proximityPrompt then
                            itemName = proximityPrompt.ObjectText or proximityPrompt.ActionText or child.Name
                        end
                        
                        if YBA_ITEM_NAMES[itemName] and YBAConfig.ItemESP.Items[itemName] then
                            for _, part in ipairs(child:GetDescendants()) do
                                if part:IsA("MeshPart") or part:IsA("Part") then
                                    local distance = (part.Position - playerRoot.Position).Magnitude
                                    
                                    foundCount = foundCount + 1
                                    
                                    table.insert(items, {
                                        Object = part,
                                        Root = part,
                                        Distance = distance,
                                        Name = itemName,
                                        Type = "YBA_Item",
                                        Folder = currentFolder.Name
                                    })
                                    break
                                end
                            end
                        end
                    end
                elseif child:IsA("Folder") and depth < 2 then
                    searchInFolder(child, depth + 1)
                end
            end
        end
        
        searchInFolder(folder, 0)
    end
    
    table.sort(items, function(a, b) return a.Distance < b.Distance end)
    
    return items
end

local function findYBAItemsFast()
    local items = {}
    local player = Players.LocalPlayer
    local playerChar = player.Character
    local playerRoot = playerChar and playerChar:FindFirstChild("HumanoidRootPart")
    if not playerRoot then 
        return items 
    end
    
    local targetFolder = workspace:FindFirstChild("Item_Spawns")
    if not targetFolder then
        return items
    end
    
    local itemsFolder = targetFolder:FindFirstChild("Items")
    if not itemsFolder then
        return items
    end
    
    local foundCount = 0
    local debugCount = 0

    for _, child in ipairs(itemsFolder:GetChildren()) do
        debugCount = debugCount + 1
        
        if child:IsA("Model") then
            local proximityPrompt = child:FindFirstChild("ProximityPrompt")
            local itemName = child.Name
            
            if proximityPrompt then
                itemName = proximityPrompt.ObjectText or proximityPrompt.ActionText or child.Name
            end
            
            if YBA_ITEM_NAMES[itemName] and YBAConfig.ItemESP.Items[itemName] then
                for _, part in ipairs(child:GetDescendants()) do
                    if part:IsA("MeshPart") or part:IsA("Part") then
                        local distance = (part.Position - playerRoot.Position).Magnitude
                        
                        foundCount = foundCount + 1
                        
                        table.insert(items, {
                            Object = part,
                            Root = part,
                            Distance = distance,
                            Name = itemName,
                            Type = "YBA_Item",
                            Folder = "Item_Spawns.Items"
                        })
                        break
                    end
                end
            else
                local lowerName = string.lower(itemName)
                if string.find(lowerName, "arrow") or 
                   string.find(lowerName, "rokakaka") or
                   string.find(lowerName, "diamond") or
                   string.find(lowerName, "coin") or
                   string.find(lowerName, "corpse") or
                   string.find(lowerName, "diary") or
                   string.find(lowerName, "disc") or
                   string.find(lowerName, "mask") or
                   string.find(lowerName, "scroll") or
                   string.find(lowerName, "glove") or
                   string.find(lowerName, "headband") or
                   string.find(lowerName, "ball") then
                    
                    for _, part in ipairs(child:GetDescendants()) do
                        if part:IsA("MeshPart") or part:IsA("Part") then
                            local distance = (part.Position - playerRoot.Position).Magnitude
                            
                            if distance <= YBAConfig.ItemESP.MaxDistance then
                                foundCount = foundCount + 1
                                print("YBA Item ESP: Быстрый поиск - найден возможный предмет", itemName, "на расстоянии", math.floor(distance), "м")
                                
                                table.insert(items, {
                                    Object = part,
                                    Root = part,
                                    Distance = distance,
                                    Name = itemName,
                                    Type = "YBA_Item",
                                    Folder = "Item_Spawns.Items"
                                })
                                break
                            end
                        end
                    end
                end
            end
        end
    end
    
    table.sort(items, function(a, b) return a.Distance < b.Distance end)
    
    return items
end

local function findYBAItemsAlternative()
    local items = {}
    local player = Players.LocalPlayer
    local playerChar = player.Character
    local playerRoot = playerChar and playerChar:FindFirstChild("HumanoidRootPart")
    if not playerRoot then 
        print("YBA Item ESP: Игрок не найден (альтернативный поиск)")
        return items 
    end

    print("YBA Item ESP: Альтернативный поиск по всему workspace...")
    
    local foundCount = 0
    local searchedModels = {}
    local debugCount = 0

    local function searchInWorkspace(parent, depth)
        if depth > 10 then return end -- Ограничиваем глубину поиска
        
        for _, child in ipairs(parent:GetChildren()) do
            debugCount = debugCount + 1
            if debugCount % 500 == 0 then
                print("YBA Item ESP: Альтернативный поиск - проверено объектов:", debugCount)
            end
            
            if child:IsA("Model") then
                if not searchedModels[child] then
                    searchedModels[child] = true

                    if YBA_ITEM_NAMES[child.Name] and YBAConfig.ItemESP.Items[child.Name] then
                        print("YBA Item ESP: Альтернативный поиск - найдена модель предмета:", child.Name)

                        for _, part in ipairs(child:GetDescendants()) do
                            if part:IsA("MeshPart") or part:IsA("Part") then
                                local distance = (part.Position - playerRoot.Position).Magnitude
                                
                                if distance <= YBAConfig.ItemESP.MaxDistance then
                                    foundCount = foundCount + 1
                                    print("YBA Item ESP: Альтернативный поиск - найден предмет", child.Name, "на расстоянии", math.floor(distance), "м")
                                    
                                    table.insert(items, {
                                        Object = part,
                                        Root = part,
                                        Distance = distance,
                                        Name = child.Name,
                                        Type = "YBA_Item",
                                        Folder = "Workspace"
                                    })
                                    break
                                end
                            end
                        end
                    else
                        if string.find(string.lower(child.Name), "arrow") or 
                           string.find(string.lower(child.Name), "rokakaka") or
                           string.find(string.lower(child.Name), "diamond") or
                           string.find(string.lower(child.Name), "coin") then
                            print("YBA Item ESP: Альтернативный поиск - найдена неизвестная модель (возможно предмет):", child.Name)
                        end
                    end
                end
            elseif child:IsA("Folder") and depth < 5 then
                searchInWorkspace(child, depth + 1)
            end
        end
    end

    searchInWorkspace(workspace, 0)

    table.sort(items, function(a, b) return a.Distance < b.Distance end)
    
    print("YBA Item ESP: Альтернативный поиск - всего проверено объектов:", debugCount)
    print("YBA Item ESP: Альтернативный поиск - всего найдено предметов:", foundCount)
    
    return items
end

local function debugWorkspaceStructure()
    print("YBA Item ESP: === ОТЛАДКА СТРУКТУРЫ WORKSPACE ===")
    
    local function printFolderStructure(parent, prefix, maxDepth)
        if maxDepth <= 0 then return end
        
        for _, child in ipairs(parent:GetChildren()) do
            local childType = child.ClassName
            local childName = child.Name
            
            print(prefix .. "├─ " .. childName .. " (" .. childType .. ")")

            if child:IsA("Folder") then
                printFolderStructure(child, prefix .. "│  ", maxDepth - 1)
            end

            if child:IsA("Model") then
                local hasMeshPart = false
                local hasPart = false
                for _, descendant in ipairs(child:GetDescendants()) do
                    if descendant:IsA("MeshPart") then
                        hasMeshPart = true
                    elseif descendant:IsA("Part") then
                        hasPart = true
                    end
                end
                if hasMeshPart or hasPart then
                    print(prefix .. "│  └─ [Содержит MeshPart/Part]")
                end
            end
        end
    end
    
    print("YBA Item ESP: Структура workspace (первые 3 уровня):")
    printFolderStructure(workspace, "", 3)
    
    print("YBA Item ESP: === КОНЕЦ ОТЛАДКИ ===")
end

local function createItemESP(item)
    if itemESPElements[item.Object] then
        return itemESPElements[item.Object]
    end
    
    if not item.Object or not item.Object.Parent then
        return nil
    end

    if item.Distance > YBAConfig.ItemESP.MaxRenderDistance then
        return nil
    end
    
    print("YBA Item ESP: Создаем ESP для предмета:", item.Name)
    
    local esp = {}
    esp.itemName = item.Name 

    local function getItemColor(itemName)
        if string.find(itemName, "Arrow") then
            return Color3.fromRGB(255, 215, 0) 
        elseif string.find(itemName, "Rokakaka") then
            return Color3.fromRGB(255, 0, 255) 
        elseif string.find(itemName, "Diamond") then
            return Color3.fromRGB(0, 255, 255) 
        elseif string.find(itemName, "Corpse") then
            return Color3.fromRGB(255, 0, 0) 
        elseif string.find(itemName, "Diary") then
            return Color3.fromRGB(255, 165, 0) 
        elseif string.find(itemName, "Disc") then
            return Color3.fromRGB(0, 255, 0)
        else
            return YBAConfig.ItemESP.FillColor 
        end
    end
    
    local itemColor = getItemColor(item.Name)

    if YBAConfig.ItemESP.ShowOutline or YBAConfig.ItemESP.ShowFill then
        local success, highlight = pcall(function()
            local hl = Instance.new("Highlight")
            hl.Adornee = item.Object
            hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            hl.FillColor = YBAConfig.ItemESP.ShowFill and itemColor or Color3.fromRGB(0, 0, 0)
            hl.FillTransparency = YBAConfig.ItemESP.ShowFill and YBAConfig.ItemESP.FillTransparency or 1
            hl.OutlineColor = YBAConfig.ItemESP.ShowOutline and YBAConfig.ItemESP.OutlineColor or Color3.fromRGB(0, 0, 0)
            hl.OutlineTransparency = YBAConfig.ItemESP.ShowOutline and YBAConfig.ItemESP.OutlineTransparency or 1
            hl.Parent = item.Object

            local pulseConnection
            pulseConnection = RunService.Heartbeat:Connect(function()
                if not hl.Parent then
                    pulseConnection:Disconnect()
                    return
                end
                
                local time = tick()
                local pulse = math.sin(time * 4) * 0.4 + 0.6
                hl.FillTransparency = YBAConfig.ItemESP.FillTransparency + (1 - pulse) * 0.4
                hl.OutlineTransparency = YBAConfig.ItemESP.OutlineTransparency + (1 - pulse) * 0.2
            end)
            
            esp.pulseConnection = pulseConnection
            
            return hl
        end)
        
        if success and highlight then
            esp.highlight = highlight
            print("YBA Item ESP: Highlight создан для:", item.Name)
        else
            print("YBA Item ESP: Ошибка при создании Highlight для:", item.Name)
        end
    end

    if YBAConfig.ItemESP.ShowText then
        local success, billboard = pcall(function()
            local bg = Instance.new("BillboardGui")
            bg.AlwaysOnTop = true
            bg.Size = UDim2.new(0, 200, 0, 50) 
            bg.StudsOffset = Vector3.new(0, 3, 0) 
            bg.Parent = item.Object

            local background = Instance.new("Frame", bg)
            background.Size = UDim2.new(1, 0, 1, 0)
            background.Position = UDim2.new(0, 0, 0, 0)
            background.BackgroundColor3 = YBAConfig.ItemESP.TextBackgroundColor
            background.BackgroundTransparency = YBAConfig.ItemESP.TextBackgroundTransparency
            background.BorderSizePixel = 0
            background.ZIndex = 1
            
            local corner = Instance.new("UICorner", background)
            corner.CornerRadius = UDim.new(0, 6) 

            local border = Instance.new("Frame", bg)
            border.Size = UDim2.new(1, 2, 1, 2)
            border.Position = UDim2.new(0, -1, 0, -1)
            border.BackgroundColor3 = itemColor
            border.BorderSizePixel = 0
            border.ZIndex = 0
            
            local borderCorner = Instance.new("UICorner", border)
            borderCorner.CornerRadius = UDim.new(0, 8) 

            local tl = Instance.new("TextLabel", bg)
            tl.Size = UDim2.new(1, -6, 0.6, 0) 
            tl.Position = UDim2.new(0, 3, 0, 2)
            tl.BackgroundTransparency = 1
            tl.Font = YBAConfig.ItemESP.Font
            tl.TextSize = YBAConfig.ItemESP.TextSize
            tl.TextColor3 = YBAConfig.ItemESP.TextColor
            tl.TextXAlignment = Enum.TextXAlignment.Center
            tl.TextYAlignment = Enum.TextYAlignment.Center
            tl.Text = string.format("🎯 %s", item.Name)
            tl.ZIndex = 3

            local distanceLabel = Instance.new("TextLabel", bg)
            distanceLabel.Size = UDim2.new(1, -6, 0.4, 0) 
            distanceLabel.Position = UDim2.new(0, 3, 0.6, 0) 
            distanceLabel.BackgroundTransparency = 1
            distanceLabel.Font = Enum.Font.Gotham
            distanceLabel.TextSize = YBAConfig.ItemESP.DistanceTextSize
            distanceLabel.TextColor3 = YBAConfig.ItemESP.TextColor
            distanceLabel.TextXAlignment = Enum.TextXAlignment.Center
            distanceLabel.TextYAlignment = Enum.TextYAlignment.Center
            distanceLabel.Text = string.format("📏 %dm", math.floor(item.Distance)) 
            distanceLabel.ZIndex = 3
            
            return {
                billboard = bg, 
                text = tl, 
                distanceLabel = distanceLabel,
                background = background,
                border = border
            }
        end)
        
        if success and billboard then
            esp.billboard = billboard.billboard
            esp.text = billboard.text
            esp.distanceLabel = billboard.distanceLabel
            esp.background = billboard.background
            esp.border = billboard.border
            print("YBA Item ESP: BillboardGui создан для:", item.Name)
        else
            print("YBA Item ESP: Ошибка при создании BillboardGui для:", item.Name)
        end
    end
    
    itemESPElements[item.Object] = esp
    return esp
end

local function updateItemESP(item)
    local esp = itemESPElements[item.Object]
    if not esp then return end

    if true then
        if not item.Object or not item.Object.Parent then
            print("YBA Item ESP: Предмет больше не существует, удаляем ESP:", item.Name)
            removeItemESP(item)
            return
        end

        local currentParent = item.Object.Parent
        while currentParent and currentParent ~= workspace do
            if currentParent.Name == "Items" and currentParent.Parent and currentParent.Parent.Name == "Item_Spawns" then
                break
            end
            currentParent = currentParent.Parent
        end
        
        if not currentParent or currentParent == workspace then
            print("YBA Item ESP: Предмет перемещен из папки Items, удаляем ESP:", item.Name)
            removeItemESP(item)
            return
        end
    end

    local function getItemColor(itemName)
        if string.find(itemName, "Arrow") then
            return Color3.fromRGB(255, 215, 0) 
        elseif string.find(itemName, "Rokakaka") then
            return Color3.fromRGB(255, 0, 255)
        elseif string.find(itemName, "Diamond") then
            return Color3.fromRGB(0, 255, 255)
        elseif string.find(itemName, "Corpse") then
            return Color3.fromRGB(255, 0, 0) 
        elseif string.find(itemName, "Diary") then
            return Color3.fromRGB(255, 165, 0) 
        elseif string.find(itemName, "Disc") then
            return Color3.fromRGB(0, 255, 0) 
        else
            return YBAConfig.ItemESP.FillColor 
        end
    end
    
    local itemColor = getItemColor(item.Name)

    if esp.text and esp.text.Parent then
        pcall(function()
            esp.text.Text = string.format("🎯 %s", item.Name)
        end)
    end

    if esp.distanceLabel and esp.distanceLabel.Parent then
        pcall(function()
            esp.distanceLabel.Text = string.format("📏 %dm", math.floor(item.Distance)) 
        end)
    end

    if esp.highlight and esp.highlight.Parent then
        pcall(function()
            esp.highlight.FillColor = YBAConfig.ItemESP.ShowFill and itemColor or Color3.fromRGB(0, 0, 0)
            esp.highlight.FillTransparency = YBAConfig.ItemESP.ShowFill and YBAConfig.ItemESP.FillTransparency or 1
            esp.highlight.OutlineColor = YBAConfig.ItemESP.ShowOutline and YBAConfig.ItemESP.OutlineColor or Color3.fromRGB(0, 0, 0)
            esp.highlight.OutlineTransparency = YBAConfig.ItemESP.ShowOutline and YBAConfig.ItemESP.OutlineTransparency or 1
        end)
    end

    if esp.border and esp.border.Parent then
        pcall(function()
            esp.border.BackgroundColor3 = itemColor
        end)
    end
end

local function removeItemESP(item)
    local esp = itemESPElements[item.Object]
    if not esp then return end

    if esp.pulseConnection then
        esp.pulseConnection:Disconnect()
        esp.pulseConnection = nil
    end

    pcall(function()
        if esp.highlight and esp.highlight.Parent then
            esp.highlight:Destroy()
        end
    end)

    pcall(function()
        if esp.billboard and esp.billboard.Parent then
            esp.billboard:Destroy()
        end
    end)

    esp.highlight = nil
    esp.billboard = nil
    esp.text = nil
    esp.distanceLabel = nil
    esp.background = nil
    esp.border = nil
    
    itemESPElements[item.Object] = nil
end

local function startItemESP()
    if itemESPEnabled then 
        print("YBA Item ESP: Уже активирован!")
        return 
    end
    itemESPEnabled = true
    
    print("YBA Item ESP: Активирован!")
    print("YBA Item ESP: Максимальная дистанция:", YBAConfig.ItemESP.MaxDistance)
    print("YBA Item ESP: Показывать обводку:", YBAConfig.ItemESP.ShowOutline)
    print("YBA Item ESP: Показывать текст:", YBAConfig.ItemESP.ShowText)

    local testItems = findYBAItems()
    print("YBA Item ESP: Активирован! Найдено предметов:", #testItems)
    
    local lastUpdate = 0
    local updateInterval = YBAConfig.ItemESP.UpdateInterval 

    local itemESPLoop = RunService.Heartbeat:Connect(function()
        if not YBAConfig.ItemESP.Enabled then
            stopItemESP()
            return
        end

        local currentTime = tick()
        if currentTime - lastUpdate < updateInterval then
            return
        end
        lastUpdate = currentTime

        local success, items = pcall(findYBAItemsFast)
        local currentItems = {}

        if not success or not items or #items == 0 then
            local success2, items2 = pcall(findYBAItems)
            if success2 and items2 and #items2 > 0 then
                items = items2
                success = true
                print("YBA Item ESP: Используем обычный поиск, найдено предметов:", #items)
            else
                local success3, items3 = pcall(findYBAItemsAlternative)
                if success3 and items3 and #items3 > 0 then
                    items = items3
                    success = true
                    print("YBA Item ESP: Используем альтернативный поиск, найдено предметов:", #items)
                end
            end
        end
        
        if success and items then
            for i = 1, math.min(100, #items) do 
                local item = items[i]
                if item and item.Object and item.Object.Parent then
                    if YBAConfig.ItemESP.Items[item.Name] then
                        currentItems[item.Object] = true

                        if not itemESPElements[item.Object] then
                            pcall(createItemESP, item)
                        else
                            pcall(updateItemESP, item)
                        end
                    else
                        if itemESPElements[item.Object] then
                            pcall(removeItemESP, item)
                        end
                    end
                end
            end

            if math.floor(currentTime) % 5 == 0 then
                print("YBA Item ESP: Активных ESP:", #items, "| Максимальная дистанция:", YBAConfig.ItemESP.MaxDistance)
            end
        end

        for obj, esp in pairs(itemESPElements) do
            if not currentItems[obj] then
                pcall(removeItemESP, {Object = obj})
            end
        end
    end)
    
    table.insert(itemESPConnections, itemESPLoop)

    local cleanupLoop = RunService.Heartbeat:Connect(function()
        if not YBAConfig.ItemESP.Enabled then
            return
        end
        
        for obj, esp in pairs(itemESPElements) do
            if not obj or not obj.Parent then
                pcall(removeItemESP, {Object = obj})
            end
        end
    end)
    
    table.insert(itemESPConnections, cleanupLoop)
end

local function stopItemESP()
    if not itemESPEnabled then return end
    itemESPEnabled = false
    
    print("YBA Item ESP: Деактивирован!")

    for obj, esp in pairs(itemESPElements) do
        pcall(removeItemESP, {Object = obj})
    end

    for _, connection in ipairs(itemESPConnections) do
        if connection then
            pcall(function() connection:Disconnect() end)
        end
    end
    itemESPConnections = {}
end


local screenGui = Instance.new("ScreenGui", CoreGui)
screenGui.Name = "SslkinGui"
screenGui.ResetOnSpawn = false

local frame = Instance.new("Frame", screenGui)
frame.Name = "MainFrame"
frame.Position = UDim2.new(0, 20, 0.5, -200)
frame.Size = UDim2.new(0, 300, 0, 0)
frame.AutomaticSize = Enum.AutomaticSize.Y
frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
frame.BorderSizePixel = 0
frame.Active = true
frame.Draggable = true

local titleBar = Instance.new("Frame", frame)
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 36)
titleBar.Position = UDim2.new(0, 0, 0, 0)
titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 30)

local titleText = Instance.new("TextLabel", titleBar)
titleText.Name = "TitleText"
titleText.Size = UDim2.new(1, -40, 1, 0)
titleText.Position = UDim2.new(0, 10, 0, 0)
titleText.BackgroundTransparency = 1
titleText.Text = "SSLKIN UNI-GUI"
titleText.Font = Enum.Font.GothamBold
titleText.TextSize = 14
titleText.TextColor3 = Color3.new(1, 1, 1)
titleText.TextXAlignment = Enum.TextXAlignment.Left

local collapseBtn = Instance.new("TextButton", titleBar)
collapseBtn.Name = "Collapse"
collapseBtn.Size = UDim2.new(0, 26, 0, 26)
collapseBtn.Position = UDim2.new(1, -30, 0.5, -13)
collapseBtn.Text = "−"
collapseBtn.Font = Enum.Font.GothamBold
collapseBtn.TextSize = 18
collapseBtn.TextColor3 = Color3.new(1, 1, 1)
collapseBtn.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
Instance.new("UICorner", collapseBtn).CornerRadius = UDim.new(0, 6)

local scroll = Instance.new("ScrollingFrame", frame)
scroll.Position = UDim2.new(0, 0, 0, 30)
scroll.Size = UDim2.new(1, 0, 1, -46)
scroll.CanvasSize = UDim2.new(0, 0, 3, 0)
scroll.ScrollBarThickness = 6
scroll.BackgroundTransparency = 1
scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
scroll.ClipsDescendants = true

local innerContainer = Instance.new("Frame", scroll)
innerContainer.Name = "InnerContainer"
innerContainer.BackgroundTransparency = 1
innerContainer.Size = UDim2.new(1, -20, 0, 0)
innerContainer.Position = UDim2.new(0, 10, 0, 0)
innerContainer.AutomaticSize = Enum.AutomaticSize.Y
innerContainer.ClipsDescendants = false

local function toggleMenu()
    Config.MenuCollapsed = not Config.MenuCollapsed
    local collapsed = Config.MenuCollapsed
    local size = collapsed and UDim2.new(0, 280, 0, 40) or UDim2.new(0, 280, 0, 800)
    local text = collapsed and "+" or "−"
    local color = collapsed and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)

    TweenService:Create(frame, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Size = size
    }):Play()

    TweenService:Create(collapseBtn, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        BackgroundColor3 = color
    }):Play()

    collapseBtn.Text = text
    scroll.Visible = not collapsed
end

collapseBtn.MouseButton1Click:Connect(toggleMenu)

UserInputService.InputBegan:Connect(function(input, gp)
    if not gp and input.KeyCode == Enum.KeyCode.Insert then
        toggleMenu()
    end
end)

local UIListLayout = Instance.new("UIListLayout", innerContainer)
UIListLayout.Padding = UDim.new(0, 8)
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder


local function sectionHeader(text)
	
	local spacer = Instance.new("Frame", innerContainer)
	spacer.Size = UDim2.new(1, 0, 0, 10)
	spacer.BackgroundTransparency = 1
	
	local lbl = Instance.new("TextLabel", innerContainer)
	lbl.Text = text
	lbl.Size = UDim2.new(1, -10, 0, 30)
	lbl.Font = Enum.Font.GothamBold
	lbl.TextSize = 16
	lbl.TextColor3 = Color3.fromRGB(255,255,255)
	lbl.BackgroundTransparency = 1
end

local function toggle(label, default, callback)
	local btn = Instance.new("TextButton", innerContainer)
	btn.Size = UDim2.new(1, -10, 0, 28)
	btn.Text = label .. ": " .. (default and "ON" or "OFF")
	btn.Font = Enum.Font.Gotham
	btn.TextSize = 14
	btn.TextColor3 = Color3.new(1,1,1)
	btn.BackgroundColor3 = Color3.fromRGB(40,40,40)
	btn.AutoButtonColor = false
	Instance.new("UICorner", btn).CornerRadius = UDim.new(0,6)

	btn.MouseButton1Click:Connect(function()
		default = not default
		btn.Text = label .. ": " .. (default and "ON" or "OFF")
		callback(default)
	end)
	
	return btn
end

local function slider(label, min, max, value, callback)
	local container = Instance.new("Frame", innerContainer)
	container.Size = UDim2.new(1, -10, 0, 36)
	container.BackgroundTransparency = 1

	local lbl = Instance.new("TextLabel", container)
	lbl.Text = label .. ": " .. value
	lbl.Size = UDim2.new(1, 0, 0.5, 0)
	lbl.Font = Enum.Font.Gotham
	lbl.TextSize = 13
	lbl.TextColor3 = Color3.new(1,1,1)
	lbl.BackgroundTransparency = 1

	local sliderBack = Instance.new("Frame", container)
	sliderBack.Position = UDim2.new(0,0,0.5,4)
	sliderBack.Size = UDim2.new(1, 0, 0, 6)
	sliderBack.BackgroundColor3 = Color3.fromRGB(50,50,50)
	Instance.new("UICorner", sliderBack).CornerRadius = UDim.new(1,0)

	local sliderFill = Instance.new("Frame", sliderBack)
	sliderFill.Size = UDim2.new((value - min) / (max - min), 0, 1, 0)
	sliderFill.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Instance.new("UICorner", sliderFill).CornerRadius = UDim.new(1,0)

	local dragging = false
	sliderBack.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
		end
	end)
	UserInputService.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = false
		end
	end)
	RunService.RenderStepped:Connect(function()
		if dragging then
			local pos = UserInputService:GetMouseLocation().X
			local abs = sliderBack.AbsolutePosition.X
			local width = sliderBack.AbsoluteSize.X
			local pct = math.clamp((pos - abs) / width, 0, 1)
			local newVal = math.floor((min + (max - min) * pct) * 10) / 10
			sliderFill.Size = UDim2.new(pct, 0, 1, 0)
			lbl.Text = label .. ": " .. newVal
			callback(newVal)
		end
	end)
end

local function colorPicker(labelText, currentColor, callback)
    local lbl = Instance.new("TextLabel", innerContainer)
    lbl.Text = labelText
    lbl.TextColor3 = Color3.new(1,1,1)
    lbl.BackgroundTransparency = 1
    lbl.Size = UDim2.new(1, -10, 0, 20)
    lbl.Font = Enum.Font.SourceSans
    lbl.TextSize = 14

    local colors = {
        Color3.fromRGB(255, 255, 255),
        Color3.fromRGB(255, 0, 0),
        Color3.fromRGB(0, 255, 0),
        Color3.fromRGB(0, 0, 255),
        Color3.fromRGB(255, 255, 0),
        Color3.fromRGB(255, 0, 255),
        Color3.fromRGB(0, 255, 255),
        Color3.fromRGB(128, 128, 128),
        Color3.fromRGB(255, 165, 0),
    }

    local row = Instance.new("Frame", innerContainer)
    row.Size = UDim2.new(1, -10, 0, 28)
    row.BackgroundTransparency = 1

    local layout = Instance.new("UIListLayout", row)
    layout.FillDirection = Enum.FillDirection.Horizontal
    layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    layout.Padding = UDim.new(0, 4)

    for _, clr in pairs(colors) do
        local btn = Instance.new("TextButton", row)
        btn.Size = UDim2.new(0, 24, 0, 24)
        btn.BackgroundColor3 = clr
        btn.Text = ""
        btn.AutoButtonColor = false
        btn.MouseButton1Click:Connect(function()
            callback(clr)
        end)
    end
end

local function speedInput(label, currentSpeed, callback)
    local container = Instance.new("Frame", innerContainer)
    container.Size = UDim2.new(1, -10, 0, 36)
    container.BackgroundTransparency = 1

    local lbl = Instance.new("TextLabel", container)
    lbl.Text = label .. ": " .. currentSpeed
    lbl.Size = UDim2.new(0.7, 0, 0.5, 0)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 13
    lbl.TextColor3 = Color3.new(1,1,1)
    lbl.BackgroundTransparency = 1

    local inputBox = Instance.new("TextBox", container)
    inputBox.Position = UDim2.new(0.7, 5, 0.25, 0)
    inputBox.Size = UDim2.new(0.3, -5, 0.5, 0)
    inputBox.Text = tostring(currentSpeed)
    inputBox.Font = Enum.Font.Gotham
    inputBox.TextSize = 12
    inputBox.TextColor3 = Color3.new(1,1,1)
    inputBox.BackgroundColor3 = Color3.fromRGB(40,40,40)
    inputBox.PlaceholderText = "Speed"
    Instance.new("UICorner", inputBox).CornerRadius = UDim.new(0,4)

    inputBox.FocusLost:Connect(function()
        local newSpeed = tonumber(inputBox.Text)
        if newSpeed and newSpeed > 0 then
            callback(newSpeed)
            lbl.Text = label .. ": " .. newSpeed
        else
            inputBox.Text = tostring(currentSpeed)
        end
    end)

    return lbl, inputBox
end

local function playerSelector(label, currentPlayer, callback)
    local container = Instance.new("Frame", innerContainer)
    container.Size = UDim2.new(1, -10, 0, 36)
    container.BackgroundTransparency = 1

    local lbl = Instance.new("TextLabel", container)
    lbl.Text = label .. ": " .. (currentPlayer and currentPlayer.Name or "None")
    lbl.Size = UDim2.new(0.7, 0, 0.5, 0)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 13
    lbl.TextColor3 = Color3.new(1,1,1)
    lbl.BackgroundTransparency = 1

    local selectBtn = Instance.new("TextButton", container)
    selectBtn.Position = UDim2.new(0.7, 5, 0.25, 0)
    selectBtn.Size = UDim2.new(0.3, -5, 0.5, 0)
    selectBtn.Text = "Выбрать игрока"
    selectBtn.Font = Enum.Font.Gotham
    selectBtn.TextSize = 12
    selectBtn.TextColor3 = Color3.new(1,1,1)
    selectBtn.BackgroundColor3 = Color3.fromRGB(40,40,40)
    Instance.new("UICorner", selectBtn).CornerRadius = UDim.new(0,4)

    selectBtn.MouseButton1Click:Connect(function()
        print("=== КНОПКА ВЫБОРА ИГРОКА НАЖАТА ===")
        
        
        createPlayerSelectionWindow()
        
        
        if TeleportConfig.TargetPlayer then
            lbl.Text = label .. ": " .. TeleportConfig.TargetPlayer.Name
            callback(TeleportConfig.TargetPlayer)
        end
    end)

    return lbl, selectBtn
end


local function keyBindButton(name, currentKey, callback)
    local btn = Instance.new("TextButton", innerContainer)
    btn.Size = UDim2.new(1, -10, 0, 24)
    btn.Text = name .. " Hotkey: [" .. (currentKey and tostring(currentKey.Name) or "None") .. "]"
    btn.BackgroundColor3 = Color3.fromRGB(40,40,40)
    btn.TextColor3 = Color3.new(1,1,1)
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 13
    btn.AutoButtonColor = false
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0,6)

    btn.MouseButton1Click:Connect(function()
        btn.Text = name .. " Hotkey: [Press any key]"
        local conn
        conn = UserInputService.InputBegan:Connect(function(input, gp)
            if not gp and input.UserInputType == Enum.UserInputType.Keyboard then
                conn:Disconnect()
                callback(input.KeyCode)
                btn.Text = name .. " Hotkey: [" .. tostring(input.KeyCode.Name) .. "]"
            end
        end)
    end)
end


keyBindButton("ESP", Config.ESP.ToggleKey, function(newKey)
    Config.ESP.ToggleKey = newKey
end)

keyBindButton("Aimbot", Config.Aimbot.ToggleKey, function(newKey)
    Config.Aimbot.ToggleKey = newKey
end)

keyBindButton("Fly", FlyConfig.ToggleKey, function(newKey)
    FlyConfig.ToggleKey = newKey
end)

keyBindButton("NoClip", NoClipConfig.ToggleKey, function(newKey)
    NoClipConfig.ToggleKey = newKey
end)

keyBindButton("SpeedHack", SpeedHackConfig.ToggleKey, function(newKey)
    SpeedHackConfig.ToggleKey = newKey
end)

keyBindButton("Teleport", TeleportConfig.ToggleKey, function(newKey)
    TeleportConfig.ToggleKey = newKey
end)

keyBindButton("YBA Stand Range", YBAConfig.ToggleKey, function(newKey)
    YBAConfig.ToggleKey = newKey
end)

sectionHeader("🔷ESP Settings")
toggle("ESP", Config.ESP.Enabled, function(v) Config.ESP.Enabled = v end)
toggle("Team Check", Config.ESP.TeamCheck, function(v) Config.ESP.TeamCheck = v end)
toggle("Show Outline", Config.ESP.ShowOutline, function(v) Config.ESP.ShowOutline = v end)
toggle("Show Lines", Config.ESP.ShowLines, function(v) Config.ESP.ShowLines = v end)
toggle("Rainbow Colors", Config.ESP.Rainbow, function(v) Config.ESP.Rainbow = v end)

colorPicker("Fill Color", Config.ESP.FillColor, function(c) Config.ESP.FillColor = c end)
colorPicker("Outline Color", Config.ESP.OutlineColor, function(c) Config.ESP.OutlineColor = c end)
colorPicker("Text Color", Config.ESP.TextColor, function(c) Config.ESP.TextColor = c end)
slider("Fill Transparency", 0, 1, Config.ESP.FillTransparency, function(v) Config.ESP.FillTransparency = v end)
slider("Outline Transparency", 0, 1, Config.ESP.OutlineTransparency, function(v) Config.ESP.OutlineTransparency = v end)

local divider1 = Instance.new("Frame", innerContainer)
divider1.Size = UDim2.new(1, -10, 0, 2)
divider1.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
divider1.BorderSizePixel = 0

sectionHeader("🔷Aimbot Settings")
toggle("Aimbot", Config.Aimbot.Enabled, function(v) Config.Aimbot.Enabled = v end)
toggle("Team Check", Config.Aimbot.TeamCheck, function(v) Config.Aimbot.TeamCheck = v end)
toggle("Visibility Check", Config.Aimbot.VisibilityCheck, function(v) Config.Aimbot.VisibilityCheck = v end)
slider("FOV Radius", 10, 500, Config.Aimbot.FOV, function(v) Config.Aimbot.FOV = v end)
toggle("FOV Rainbow", Config.Aimbot.FOVRainbow, function(v) Config.Aimbot.FOVRainbow = v end)
colorPicker("Aimbot FOV Color", Config.Aimbot.FOVColor, function(c) Config.Aimbot.FOVColor = c end)

local divider2 = Instance.new("Frame", innerContainer)
divider2.Size = UDim2.new(1, -10, 0, 2)
divider2.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
divider2.BorderSizePixel = 0

local guiCallbacks = {}

local function updateStatusDisplay()
    if guiCallbacks.fly then
        guiCallbacks.fly.Text = "Fly: " .. (FlyConfig.Enabled and "ON" or "OFF")
    end
    if guiCallbacks.noClip then
        guiCallbacks.noClip.Text = "NoClip: " .. (NoClipConfig.Enabled and "ON" or "OFF")
    end
    if guiCallbacks.speedHack then
        guiCallbacks.speedHack.Text = "SpeedHack: " .. (SpeedHackConfig.Enabled and "ON" or "OFF")
    end
    if guiCallbacks.teleport then
        guiCallbacks.teleport.Text = "Selected Player: " .. (TeleportConfig.SelectedPlayerName or "None")
    end
    if guiCallbacks.yba then
        guiCallbacks.yba.Text = "YBA Stand Range: " .. (YBAConfig.Enabled and "ON" or "OFF")
    end
    if guiCallbacks.itemESP then
        guiCallbacks.itemESP.Text = "Item ESP: " .. (YBAConfig.ItemESP.Enabled and "ON" or "OFF")
    end
    if guiCallbacks.antiTimeStop then
        if isAntiTimeStopEnabled then
            guiCallbacks.antiTimeStop.Text = "Anti Time Stop: ACTIVE"
        else
            guiCallbacks.antiTimeStop.Text = "Anti Time Stop: READY"
        end
    end
end

RunService.Heartbeat:Connect(function()
    updateStatusDisplay()
end)

sectionHeader("🟨 Fly Settings")

local flyToggleBtn = toggle("Fly", FlyConfig.Enabled, function(v)
    FlyConfig.Enabled = v
    if v then startFly() else stopFly() end
    
    if guiCallbacks.fly then
        guiCallbacks.fly.Text = "Fly: " .. (v and "ON" or "OFF")
    end
end)
guiCallbacks.fly = flyToggleBtn

slider("Fly Speed", 0.1, 10, FlyConfig.Speed, function(v)
    FlyConfig.Speed = v
end)

speedInput("Custom Fly Speed", FlyConfig.Speed, function(v)
    FlyConfig.Speed = v
end)

local divider3 = Instance.new("Frame", innerContainer)
divider3.Size = UDim2.new(1, -10, 0, 2)
divider3.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
divider3.BorderSizePixel = 0

sectionHeader("🟪 NoClip Settings")

local noClipStatusLabel = Instance.new("TextLabel", innerContainer)
noClipStatusLabel.Size = UDim2.new(1, -10, 0, 20)
noClipStatusLabel.Text = "NoClip Status: OFF"
noClipStatusLabel.Font = Enum.Font.GothamBold
noClipStatusLabel.TextSize = 12
noClipStatusLabel.TextColor3 = Color3.fromRGB(255,100,100)
noClipStatusLabel.BackgroundTransparency = 1
noClipStatusLabel.TextXAlignment = Enum.TextXAlignment.Left

local forceNoClipBtn = Instance.new("TextButton", innerContainer)
forceNoClipBtn.Size = UDim2.new(1, -10, 0, 28)
forceNoClipBtn.Text = "FORCE NOCLIP TOGGLE"
forceNoClipBtn.Font = Enum.Font.GothamBold
forceNoClipBtn.TextSize = 14
forceNoClipBtn.TextColor3 = Color3.new(1,1,1)
forceNoClipBtn.BackgroundColor3 = Color3.fromRGB(100,100,255)
forceNoClipBtn.AutoButtonColor = false
Instance.new("UICorner", forceNoClipBtn).CornerRadius = UDim.new(0,6)

local function updateNoClipStatus()
    if isNoClipping then
        noClipStatusLabel.Text = "NoClip Status: ON"
        noClipStatusLabel.TextColor3 = Color3.fromRGB(100,255,100)
        forceNoClipBtn.Text = "FORCE NOCLIP TOGGLE"
        forceNoClipBtn.BackgroundColor3 = Color3.fromRGB(100,100,255)
    else
        noClipStatusLabel.Text = "NoClip Status: OFF"
        noClipStatusLabel.TextColor3 = Color3.fromRGB(255,100,100)
        forceNoClipBtn.Text = "FORCE NOCLIP TOGGLE"
        forceNoClipBtn.BackgroundColor3 = Color3.fromRGB(100,100,255)
    end
end

forceNoClipBtn.MouseButton1Click:Connect(function()
    if isNoClipping then
        stopNoClip()
        forceNoClipBtn.Text = "NOCLIP DISABLED"
        forceNoClipBtn.BackgroundColor3 = Color3.fromRGB(255,100,100)
        task.wait(1)
        updateNoClipStatus()
    else
        startNoClip()
        forceNoClipBtn.Text = "NOCLIP ENABLED"
        forceNoClipBtn.BackgroundColor3 = Color3.fromRGB(100,255,100)
        task.wait(1)
        updateNoClipStatus()
    end
end)

RunService.Heartbeat:Connect(function()
    updateNoClipStatus()
end)

local forceNoClipKeyBtn = Instance.new("TextButton", innerContainer)
forceNoClipKeyBtn.Size = UDim2.new(1, -10, 0, 24)
forceNoClipKeyBtn.Text = "Force NoClip Hotkey: [" .. (NoClipConfig.ForceToggleKey and tostring(NoClipConfig.ForceToggleKey.Name) or "None") .. "]"
forceNoClipKeyBtn.BackgroundColor3 = Color3.fromRGB(40,40,40)
forceNoClipKeyBtn.TextColor3 = Color3.new(1,1,1)
forceNoClipKeyBtn.Font = Enum.Font.Gotham
forceNoClipKeyBtn.TextSize = 13
forceNoClipKeyBtn.AutoButtonColor = false
Instance.new("UICorner", forceNoClipKeyBtn).CornerRadius = UDim.new(0,6)

forceNoClipKeyBtn.MouseButton1Click:Connect(function()
    forceNoClipKeyBtn.Text = "Force NoClip Hotkey: [Press any key]"
    local conn
    conn = UserInputService.InputBegan:Connect(function(input, gp)
        if not gp and input.UserInputType == Enum.UserInputType.Keyboard then
            conn:Disconnect()
            NoClipConfig.ForceToggleKey = input.KeyCode
            forceNoClipKeyBtn.Text = "Force NoClip Hotkey: [" .. tostring(input.KeyCode.Name) .. "]"
        end
    end)
end)



local divider4 = Instance.new("Frame", innerContainer)
divider4.Size = UDim2.new(1, -10, 0, 2)
divider4.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
divider4.BorderSizePixel = 0

sectionHeader("🟦 SpeedHack Settings")

local speedHackToggleBtn = toggle("SpeedHack", SpeedHackConfig.Enabled, function(v)
    SpeedHackConfig.Enabled = v
    if v then startSpeedHack() else stopSpeedHack() end
    
    if guiCallbacks.speedHack then
        guiCallbacks.speedHack.Text = "SpeedHack: " .. (v and "ON" or "OFF")
    end
end)
guiCallbacks.speedHack = speedHackToggleBtn

toggle("Use JumpPower Method", SpeedHackConfig.UseJumpPower, function(v)
    SpeedHackConfig.UseJumpPower = v
    
    if SpeedHackConfig.Enabled then
        stopSpeedHack()
        startSpeedHack()
    end
end)

slider("SpeedHack Speed", 0.1, 10, SpeedHackConfig.Speed, function(v)
    SpeedHackConfig.Speed = v
    
    if SpeedHackConfig.Enabled then
        local char = Players.LocalPlayer.Character
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if hum then
            hum.WalkSpeed = v * 16
            if SpeedHackConfig.UseJumpPower then
                hum.JumpPower = v * 50
            end
        end
    end
end)

speedInput("Custom SpeedHack Speed", SpeedHackConfig.Speed, function(v)
    SpeedHackConfig.Speed = v
    if SpeedHackConfig.Enabled then
        local char = Players.LocalPlayer.Character
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if hum then
            hum.WalkSpeed = v * 16
            if SpeedHackConfig.UseJumpPower then
                hum.JumpPower = v * 50
            end
        end
    end
end)

local divider5 = Instance.new("Frame", innerContainer)
divider5.Position = UDim2.new(0, 5, 0, yOffset)
divider5.Size = UDim2.new(1, -10, 0, 2)
divider5.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
divider5.BorderSizePixel = 0

sectionHeader("🦘 Jump Settings")

local longJumpToggleBtn = toggle("Long Jump", LongJumpConfig.Enabled, function(v)
    LongJumpConfig.Enabled = v
    if v then startLongJump() else stopLongJump() end
    if guiCallbacks.longJump then
        guiCallbacks.longJump.Text = "Long Jump: " .. (v and "ON" or "OFF")
    end
end)
guiCallbacks.longJump = longJumpToggleBtn

slider("Long Jump Power", 50, 500, LongJumpConfig.JumpPower, function(v)
    LongJumpConfig.JumpPower = v
    if LongJumpConfig.Enabled then
        local char = Players.LocalPlayer.Character
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if hum then
            hum.JumpPower = v
        end
    end
end)

local infiniteJumpToggleBtn = toggle("Infinite Jump", InfiniteJumpConfig.Enabled, function(v)
    InfiniteJumpConfig.Enabled = v
    if v then startInfiniteJump() else stopInfiniteJump() end
    if guiCallbacks.infiniteJump then
        guiCallbacks.infiniteJump.Text = "Infinite Jump: " .. (v and "ON" or "OFF")
    end
end)
guiCallbacks.infiniteJump = infiniteJumpToggleBtn

slider("Infinite Jump Power", 20, 150, InfiniteJumpConfig.JumpPower, function(v)
    InfiniteJumpConfig.JumpPower = v
end)

local divider6 = Instance.new("Frame", innerContainer)
divider6.Size = UDim2.new(1, -10, 0, 2)
divider6.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
divider6.BorderSizePixel = 0

sectionHeader("🟪 YBA Hacks")

local standRangeLabel = Instance.new("TextLabel", innerContainer)
standRangeLabel.Size = UDim2.new(1, -10, 0, 20)
standRangeLabel.Text = "stand range hack"
standRangeLabel.Font = Enum.Font.Gotham
standRangeLabel.TextSize = 12
standRangeLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
standRangeLabel.BackgroundTransparency = 1
standRangeLabel.TextXAlignment = Enum.TextXAlignment.Left

local ybaToggleBtn = toggle("YBA Stand Range", YBAConfig.Enabled, function(v)
    YBAConfig.Enabled = v
    if v then 
        startYBA() 
    else 
        stopYBA() 
    end
    if guiCallbacks.yba then
        guiCallbacks.yba.Text = "YBA Stand Range: " .. (v and "ON" or "OFF")
    end
end)
guiCallbacks.yba = ybaToggleBtn

ybaToggleBtn.AutoButtonColor = false

local itemESPLabel = Instance.new("TextLabel", innerContainer)
itemESPLabel.Size = UDim2.new(1, -10, 0, 20)
itemESPLabel.Text = "item esp"
itemESPLabel.Font = Enum.Font.Gotham
itemESPLabel.TextSize = 12
itemESPLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
itemESPLabel.BackgroundTransparency = 1
itemESPLabel.TextXAlignment = Enum.TextXAlignment.Left

local itemESPToggleBtn = toggle("Item ESP", YBAConfig.ItemESP.Enabled, function(v)
    YBAConfig.ItemESP.Enabled = v
    if v then 
        startItemESP() 
    else 
        stopItemESP() 
    end
    if guiCallbacks.itemESP then
        guiCallbacks.itemESP.Text = "Item ESP: " .. (v and "ON" or "OFF")
    end
end)
guiCallbacks.itemESP = itemESPToggleBtn

itemESPToggleBtn.AutoButtonColor = false

local itemSelectionHeader = Instance.new("TextLabel", innerContainer)
itemSelectionHeader.Size = UDim2.new(1, -10, 0, 25)
itemSelectionHeader.Text = "📦 ITEM SELECTION"
itemSelectionHeader.Font = Enum.Font.GothamBold
itemSelectionHeader.TextSize = 14
itemSelectionHeader.TextColor3 = Color3.fromRGB(255, 255, 0)
itemSelectionHeader.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
itemSelectionHeader.BorderSizePixel = 1
itemSelectionHeader.BorderColor3 = Color3.fromRGB(100, 100, 120)
itemSelectionHeader.TextXAlignment = Enum.TextXAlignment.Left
Instance.new("UICorner", itemSelectionHeader).CornerRadius = UDim.new(0,4)

local function createItemToggle(itemName, defaultState)
    local btn = toggle(itemName, defaultState, function(v)
        YBAConfig.ItemESP.Items[itemName] = v
        print("YBA Item ESP: Предмет", itemName, "установлен в", v and "ON" or "OFF")

        if YBAConfig.ItemESP.Enabled then
            if not v then
                for obj, esp in pairs(itemESPElements) do
                    if esp.itemName == itemName then
                        pcall(removeItemESP, {Object = obj})
                    end
                end
            end
        end
    end)
    return btn
end

createItemToggle("Mysterious Arrow", YBAConfig.ItemESP.Items["Mysterious Arrow"])
createItemToggle("Rokakaka", YBAConfig.ItemESP.Items["Rokakaka"])
createItemToggle("Pure Rokakaka", YBAConfig.ItemESP.Items["Pure Rokakaka"])
createItemToggle("Diamond", YBAConfig.ItemESP.Items["Diamond"])
createItemToggle("Gold Coin", YBAConfig.ItemESP.Items["Gold Coin"])
createItemToggle("Steel Ball", YBAConfig.ItemESP.Items["Steel Ball"])
createItemToggle("Clackers", YBAConfig.ItemESP.Items["Clackers"])
createItemToggle("Caesar's Headband", YBAConfig.ItemESP.Items["Caesar's Headband"])
createItemToggle("Zeppeli's Hat", YBAConfig.ItemESP.Items["Zeppeli's Hat"])
createItemToggle("Zeppeli's Scarf", YBAConfig.ItemESP.Items["Zeppeli's Scarf"])
createItemToggle("Quinton's Glove", YBAConfig.ItemESP.Items["Quinton's Glove"])
createItemToggle("Stone Mask", YBAConfig.ItemESP.Items["Stone Mask"])
createItemToggle("Rib Cage of The Saint's Corpse", YBAConfig.ItemESP.Items["Rib Cage of The Saint's Corpse"])
createItemToggle("Ancient Scroll", YBAConfig.ItemESP.Items["Ancient Scroll"])
createItemToggle("DIO's Diary", YBAConfig.ItemESP.Items["DIO's Diary"])
createItemToggle("DIO's Bone", YBAConfig.ItemESP.Items["DIO's Bone"])
createItemToggle("DIO's Diary Page", YBAConfig.ItemESP.Items["DIO's Diary Page"])
createItemToggle("Lucky Stone Mask", YBAConfig.ItemESP.Items["Lucky Stone Mask"])
createItemToggle("Lucky Arrow", YBAConfig.ItemESP.Items["Lucky Arrow"])

local divider7 = Instance.new("Frame", innerContainer)
divider7.Size = UDim2.new(1, -10, 0, 2)
divider7.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
divider7.BorderSizePixel = 0

local antiTimeStopLabel = Instance.new("TextLabel", innerContainer)
antiTimeStopLabel.Size = UDim2.new(1, -10, 0, 20)
antiTimeStopLabel.Text = "anti time stop"
antiTimeStopLabel.Font = Enum.Font.Gotham
antiTimeStopLabel.TextSize = 12
antiTimeStopLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
antiTimeStopLabel.BackgroundTransparency = 1
antiTimeStopLabel.TextXAlignment = Enum.TextXAlignment.Left

local antiTimeStopToggleBtn = toggle("Anti Time Stop (0.5s)", false, function(v)
    -- Игнорируем значение v, так как теперь это временная активация
    if not isAntiTimeStopEnabled then
        -- Включаем Anti Time Stop
        AntiTimeStopConfig.Enabled = true
        startAntiTimeStop()
        
        if guiCallbacks.antiTimeStop then
            guiCallbacks.antiTimeStop.Text = "Anti Time Stop: ACTIVATING..."
        end
        
        -- Асинхронно ждем 0.5 секунды и выключаем
        spawn(function()
            task.wait(0.5)
            
            -- Выключаем Anti Time Stop
            AntiTimeStopConfig.Enabled = false
            stopAntiTimeStop()
            
            if guiCallbacks.antiTimeStop then
                guiCallbacks.antiTimeStop.Text = "Anti Time Stop: READY"
            end
        end)
    else
        -- Если уже активно, показываем сообщение
        if guiCallbacks.antiTimeStop then
            guiCallbacks.antiTimeStop.Text = "Anti Time Stop: ALREADY ACTIVE"
            spawn(function()
                task.wait(1)
                guiCallbacks.antiTimeStop.Text = "Anti Time Stop: READY"
            end)
        end
    end
end)
guiCallbacks.antiTimeStop = antiTimeStopToggleBtn



local divider8 = Instance.new("Frame", innerContainer)
divider8.Size = UDim2.new(1, -10, 0, 2)
divider8.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
divider8.BorderSizePixel = 0

sectionHeader("🟩 Teleport Settings")

local teleportSpacer = Instance.new("Frame", innerContainer)
teleportSpacer.Size = UDim2.new(1, -10, 0, 10)
teleportSpacer.BackgroundTransparency = 1

local selectedPlayerLabel = Instance.new("TextLabel", innerContainer)
selectedPlayerLabel.Size = UDim2.new(1, -10, 0, 24)
selectedPlayerLabel.Text = "Selected Player: " .. (TeleportConfig.SelectedPlayerName or "None")
selectedPlayerLabel.Font = Enum.Font.GothamBold
selectedPlayerLabel.TextSize = 14
selectedPlayerLabel.TextColor3 = Color3.new(1,1,1)
selectedPlayerLabel.BackgroundTransparency = 1
selectedPlayerLabel.TextXAlignment = Enum.TextXAlignment.Left

local startTeleportBtn = Instance.new("TextButton", innerContainer)
startTeleportBtn.Size = UDim2.new(1, -10, 0, 28)
startTeleportBtn.Text = "START TELEPORT"
startTeleportBtn.Font = Enum.Font.GothamBold
startTeleportBtn.TextSize = 14
startTeleportBtn.TextColor3 = Color3.new(1,1,1)
startTeleportBtn.BackgroundColor3 = Color3.fromRGB(0,150,0)
startTeleportBtn.AutoButtonColor = false
Instance.new("UICorner", startTeleportBtn).CornerRadius = UDim.new(0,6)

startTeleportBtn.MouseButton1Click:Connect(function()
    if not TeleportConfig.TargetPlayer then
        startTeleportBtn.Text = "Select player first!"
        task.wait(2)
        startTeleportBtn.Text = "START TELEPORT"
        return
    end
    
    if TeleportConfig.Enabled then
        stopTeleport()
        TeleportConfig.Enabled = false
        startTeleportBtn.Text = "START TELEPORT"
        startTeleportBtn.BackgroundColor3 = Color3.fromRGB(0,150,0)
    else
        startTeleport()
        TeleportConfig.Enabled = true
        startTeleportBtn.Text = "STOP TELEPORT"
        startTeleportBtn.BackgroundColor3 = Color3.fromRGB(150,0,0)
    end
end)

local stopTeleportBtn = Instance.new("TextButton", innerContainer)
stopTeleportBtn.Size = UDim2.new(1, -10, 0, 28)
stopTeleportBtn.Text = "STOP TELEPORT"
stopTeleportBtn.Font = Enum.Font.GothamBold
stopTeleportBtn.TextSize = 14
stopTeleportBtn.TextColor3 = Color3.new(1,1,1)
stopTeleportBtn.BackgroundColor3 = Color3.fromRGB(150,0,0)
stopTeleportBtn.AutoButtonColor = false
Instance.new("UICorner", stopTeleportBtn).CornerRadius = UDim.new(0,6)

stopTeleportBtn.MouseButton1Click:Connect(function()
    if TeleportConfig.Enabled then
        stopTeleport()
        TeleportConfig.Enabled = false
        startTeleportBtn.Text = "START TELEPORT"
        startTeleportBtn.BackgroundColor3 = Color3.fromRGB(0,150,0)
        stopTeleportBtn.Text = "Teleport stopped"
        task.wait(2)
        stopTeleportBtn.Text = "STOP TELEPORT"
    else
        stopTeleportBtn.Text = "Teleport not active"
        task.wait(2)
        stopTeleportBtn.Text = "STOP TELEPORT"
    end
end)

local function createPlayerListInMenu()
    local allPlayers = Players:GetPlayers()
    local alivePlayers = {}
    
    for _, player in ipairs(allPlayers) do
        if player and player ~= Players.LocalPlayer then
            table.insert(alivePlayers, player)
        end
    end
    
    table.sort(alivePlayers, function(a, b)
        return a.Name:lower() < b.Name:lower()
    end)
    
    print("Создаем отсортированный список игроков в меню: " .. #alivePlayers .. " игроков")
    
    local currentLetter = ""
    for i, player in ipairs(alivePlayers) do
        local firstLetter = player.Name:sub(1,1):upper()
        
        if firstLetter ~= currentLetter then
            currentLetter = firstLetter
            
            local letterHeader = Instance.new("TextLabel", innerContainer)
            letterHeader.Size = UDim2.new(1, -10, 0, 20)
            letterHeader.Text = "--- " .. currentLetter .. " ---"
            letterHeader.Font = Enum.Font.GothamBold
            letterHeader.TextSize = 12
            letterHeader.TextColor3 = Color3.fromRGB(255,255,0)
            letterHeader.BackgroundColor3 = Color3.fromRGB(30,30,40)
            letterHeader.BorderSizePixel = 0
            letterHeader.TextXAlignment = Enum.TextXAlignment.Center
            Instance.new("UICorner", letterHeader).CornerRadius = UDim.new(0,4)
        end
        
        local playerBtn = Instance.new("TextButton", innerContainer)
        playerBtn.Size = UDim2.new(1, -10, 0, 30)
        playerBtn.Text = player.Name
        playerBtn.Font = Enum.Font.Gotham
        playerBtn.TextSize = 12
        playerBtn.TextColor3 = Color3.new(1,1,1)
        playerBtn.BackgroundColor3 = Color3.fromRGB(50,50,60)
        playerBtn.AutoButtonColor = false
        playerBtn.BorderSizePixel = 1
        playerBtn.BorderColor3 = Color3.fromRGB(100,100,120)
        Instance.new("UICorner", playerBtn).CornerRadius = UDim.new(0,4)
        
        playerBtn.MouseEnter:Connect(function()
            playerBtn.BackgroundColor3 = Color3.fromRGB(70,70,80)
            playerBtn.BorderColor3 = Color3.fromRGB(150,150,170)
        end)
        
        playerBtn.MouseLeave:Connect(function()
            playerBtn.BackgroundColor3 = Color3.fromRGB(50,50,60)
            playerBtn.BorderColor3 = Color3.fromRGB(100,100,120)
        end)
        
        playerBtn.MouseButton1Click:Connect(function()
            for _, btn in ipairs(innerContainer:GetChildren()) do
                if btn:IsA("TextButton") and 
                   btn ~= startTeleportBtn and 
                   btn ~= stopTeleportBtn and 
                   btn ~= updatePlayersBtn and
                   btn.Size.Y.Offset == 30 then
                    btn.BackgroundColor3 = Color3.fromRGB(50,50,60)
                    btn.BorderColor3 = Color3.fromRGB(100,100,120)
                end
            end
            
            playerBtn.BackgroundColor3 = Color3.fromRGB(0,150,0)
            playerBtn.BorderColor3 = Color3.fromRGB(0,200,0)
            
            TeleportConfig.TargetPlayer = player
            TeleportConfig.SelectedPlayerName = player.Name
            TeleportConfig.OriginalPosition = nil 
            selectedPlayerLabel.Text = "Selected Player: " .. player.Name
        end)
    end
end
createPlayerListInMenu()

guiCallbacks.teleport = selectedPlayerLabel

local function updatePlayerList()
    local tempContainer = Instance.new("Frame")
    tempContainer.Name = "TempPlayerList"
    tempContainer.Parent = nil
    
    local allPlayers = Players:GetPlayers()
    local alivePlayers = {}
    for _, player in ipairs(allPlayers) do
        if player and player ~= Players.LocalPlayer then
            table.insert(alivePlayers, player)
        end
    end
    
    table.sort(alivePlayers, function(a, b)
        return a.Name:lower() < b.Name:lower()
    end)
    
    local currentLetter = ""
    for i, player in ipairs(alivePlayers) do
        local firstLetter = player.Name:sub(1,1):upper()
        
        if firstLetter ~= currentLetter then
            currentLetter = firstLetter
            
            local letterHeader = Instance.new("TextLabel", tempContainer)
            letterHeader.Size = UDim2.new(1, -10, 0, 20)
            letterHeader.Text = "--- " .. currentLetter .. " ---"
            letterHeader.Font = Enum.Font.GothamBold
            letterHeader.TextSize = 12
            letterHeader.TextColor3 = Color3.fromRGB(255,255,0)
            letterHeader.BackgroundColor3 = Color3.fromRGB(30,30,40)
            letterHeader.BorderSizePixel = 0
            letterHeader.TextXAlignment = Enum.TextXAlignment.Center
            Instance.new("UICorner", letterHeader).CornerRadius = UDim.new(0,4)
        end
        
        local playerBtn = Instance.new("TextButton", tempContainer)
        playerBtn.Size = UDim2.new(1, -10, 0, 30)
        playerBtn.Text = player.Name
        playerBtn.Font = Enum.Font.Gotham
        playerBtn.TextSize = 12
        playerBtn.TextColor3 = Color3.new(1,1,1)
        playerBtn.BackgroundColor3 = Color3.fromRGB(50,50,60)
        playerBtn.AutoButtonColor = false
        playerBtn.BorderSizePixel = 1
        playerBtn.BorderColor3 = Color3.fromRGB(100,100,120)
        Instance.new("UICorner", playerBtn).CornerRadius = UDim.new(0,4)
        
        playerBtn.MouseEnter:Connect(function()
            playerBtn.BackgroundColor3 = Color3.fromRGB(70,70,80)
            playerBtn.BorderColor3 = Color3.fromRGB(150,150,170)
        end)
        
        playerBtn.MouseLeave:Connect(function()
            playerBtn.BackgroundColor3 = Color3.fromRGB(50,50,60)
            playerBtn.BorderColor3 = Color3.fromRGB(100,100,120)
        end)
        
        playerBtn.MouseButton1Click:Connect(function()
            for _, btn in ipairs(innerContainer:GetChildren()) do
                if btn:IsA("TextButton") and 
                   btn ~= startTeleportBtn and 
                   btn ~= stopTeleportBtn and 
                   btn ~= updatePlayersBtn and
                   btn.Size.Y.Offset == 30 then
                    btn.BackgroundColor3 = Color3.fromRGB(50,50,60)
                    btn.BorderColor3 = Color3.fromRGB(100,100,120)
                end
            end
            
            playerBtn.BackgroundColor3 = Color3.fromRGB(0,150,0)
            playerBtn.BorderColor3 = Color3.fromRGB(0,200,0)
            
            TeleportConfig.TargetPlayer = player
            TeleportConfig.SelectedPlayerName = player.Name
            TeleportConfig.OriginalPosition = nil 
            selectedPlayerLabel.Text = "Selected Player: " .. player.Name
        end)
    end
    
    for _, child in ipairs(innerContainer:GetChildren()) do
        if child:IsA("TextButton") then
            if child.Text and child.Text:len() > 0 and 
               not child.Text:find("UPDATE") and 
               not child.Text:find("ESP") and 
               not child.Text:find("Aimbot") and 
               not child.Text:find("Fly") and 
               not child.Text:find("NoClip") and 
               not child.Text:find("SpeedHack") and 
               not child.Text:find("Team Check") and 
               not child.Text:find("Show Outline") and 
               not child.Text:find("Show Lines") and 
               not child.Text:find("Rainbow Colors") and 
               not child.Text:find("Fill Color") and 
               not child.Text:find("Outline Color") and 
               not child.Text:find("Text Color") and 
               not child.Text:find("Fill Transparency") and 
               not child.Text:find("Outline Transparency") and 
               not child.Text:find("Visibility Check") and 
               not child.Text:find("FOV Radius") and 
               not child.Text:find("FOV Rainbow") and 
               not child.Text:find("Aimbot FOV Color") and 
               not child.Text:find("Fly Speed") and 
               not child.Text:find("Custom Fly Speed") and 
               not child.Text:find("Use JumpPower Method") and 
               not child.Text:find("SpeedHack Speed") and 
               not child.Text:find("Custom SpeedHack Speed") and 
               not child.Text:find("START TELEPORT") and 
               not child.Text:find("STOP TELEPORT") and 
               not child.Text:find("Hotkey:") and 
               not child.Text:find("YBA Stand Range") and 
               not child.Text:find("Item ESP") and 
               child.Size.Y.Offset == 30 then
                child:Destroy()
            end
        end
    end
    
    for _, child in ipairs(innerContainer:GetChildren()) do
        if child:IsA("TextLabel") and child.Text and child.Text:find("---") then
            child:Destroy()
        end
    end
    
    for _, child in ipairs(tempContainer:GetChildren()) do
        child.Parent = innerContainer
    end
    
    tempContainer:Destroy()
end

local updatePlayersBtn = Instance.new("TextButton", innerContainer)
updatePlayersBtn.Size = UDim2.new(1, -10, 0, 28)
updatePlayersBtn.Text = "UPDATE PLAYER LIST"
updatePlayersBtn.Font = Enum.Font.GothamBold
updatePlayersBtn.TextSize = 14
updatePlayersBtn.TextColor3 = Color3.new(1,1,1)
updatePlayersBtn.BackgroundColor3 = Color3.fromRGB(100,150,255)
updatePlayersBtn.AutoButtonColor = false
Instance.new("UICorner", updatePlayersBtn).CornerRadius = UDim.new(0,6)

updatePlayersBtn.MouseButton1Click:Connect(function()
    updatePlayersBtn.Text = "UPDATING..."
    updatePlayerList()
    task.wait(1)
    updatePlayersBtn.Text = "LIST UPDATED!"
    task.wait(2)
    updatePlayersBtn.Text = "UPDATE PLAYER LIST"
    
    task.spawn(function()
        task.wait(5)
    end)
end)

task.spawn(function()
    while true do
        task.wait(30)
        updatePlayerList()
    end
end)
